{
  "version": 3,
  "sources": ["../src/dom/config.ts", "../src/dom/mod.ts", "../src/utils.ts", "../src/templating/html.ts", "../src/dom/NuBuilder.ts", "../src/dom/tracking.ts", "../src/dom/nu.ts", "../src/stores/Store.ts", "../src/stores/ListStore.ts", "../src/stores/MapStore.ts", "../src/stores/mod.ts", "../src/templating/mustache.ts", "../src/campfire.ts"],
  "sourcesContent": ["// deno-lint-ignore-file no-window\n/**\n * Define minimally required interface for Document implementation\n * This includes only the methods and properties we actually use\n */\nexport interface CfDocumentInterface {\n  createElement(tagName: string): HTMLElement;\n  createDocumentFragment(): DocumentFragment;\n  querySelector(selectors: string): Element | null;\n  querySelectorAll(selectors: string): NodeListOf<Element>;\n  body: HTMLElement;\n}\n\n/**\n * Define minimally required interface for Window implementation\n * This includes only the methods and properties we actually use\n */\nexport interface CfWindowInterface {\n  document: Document;\n}\n\n/**\n * Define minimally required interface for HTMLElement constructor\n */\nexport interface CfHTMLElementConstructor {\n  new(): CfHTMLElementInterface;\n  prototype: CfHTMLElementInterface;\n}\n\n/**\n * Only the properties of HTMLElement that are actually used in Campfire.\n */\nexport type CfHTMLElementInterface = Pick<\n  HTMLElement,\n  'innerHTML' |\n  'classList' |\n  'setAttribute' |\n  'getAttribute' |\n  'hasAttribute' |\n  'removeAttribute' |\n  'addEventListener' |\n  'style' |\n  'id' |\n  'tagName' |\n  'className' |\n  'attributes'\n> & Node;\n\n/**\n * DOMShim provides a configurable interface for core DOM operations.\n * \n * This allows Campfire to work in both browser environments \n * (using native DOM) and server environments (using a DOM implementation\n * like jsdom or happy-dom).\n * \n * Usage examples:\n * \n * 1. Browser environment (automatic initialization):\n *    ```ts\n *    import { CfDom } from './dom/config';\n *    \n *    // Methods are already initialized with browser DOM\n *    const element = CfDom.createElement('div');\n *    element.innerHTML = 'Hello world';\n *    ```\n * \n * 2. Server-side rendering with custom DOM implementation:\n *    ```ts\n *    import { CfDom } from './dom/config';\n *    import { JSDOM } from 'jsdom';\n *    \n *    // Setup a custom DOM environment\n *    const dom = new JSDOM('<!DOCTYPE html><html><body></body></html>');\n *    \n *    // Configure CfDom to use jsdom\n *    CfDom.configure({\n *      document: dom.window.document,\n *      window: dom.window,\n *      HTMLElement: dom.window.HTMLElement\n *    });\n *    \n *    // Now use the shim methods with jsdom backing\n *    const element = CfDom.createElement('div');\n *    ```\n * \n * Note: This implementation uses a \"minimal API\" approach, where only document-level\n * methods (createElement, querySelector, etc.) are provided by CfDom, and element-level\n * operations are performed directly on the elements themselves.\n */\nexport class CfDom {\n  // Use a different name for the private field to avoid naming conflicts with getter\n  private static _document: CfDocumentInterface | null = null;\n  private static _window: CfWindowInterface | null = null;\n  private static _HTMLElement: CfHTMLElementConstructor | null = null;\n  private static _initialized = false;\n  static ssr: boolean = false;\n\n  // Public accessor for document\n  public static get document(): CfDocumentInterface | null {\n    return CfDom._document;\n  }\n\n  /**\n   * Initialize the shim by attempting to detect browser environment.\n   * If in a browser, use the native DOM objects; otherwise, leave them unset.\n   */\n  public static initialize(): void {\n    if (CfDom._initialized) return;\n\n    try {\n      // Check if we're in a browser environment\n      if (typeof window !== 'undefined' && window.document) {\n        CfDom._document = window.document;\n        CfDom._window = window;\n        CfDom._HTMLElement = window.HTMLElement;\n      }\n    } catch {\n      // We're likely in a non-browser environment\n    }\n\n    CfDom._initialized = true;\n  }\n\n  /**\n   * Configure the shim with custom DOM implementation.\n   */\n  public static configure(options: {\n    document?: CfDocumentInterface;\n    window?: CfWindowInterface;\n    HTMLElement?: CfHTMLElementConstructor;\n    ssr?: boolean;\n  }): void {\n    if (options.document) CfDom._document = options.document;\n    if (options.window) CfDom._window = options.window;\n    if (options.HTMLElement) CfDom._HTMLElement = options.HTMLElement;\n    if (typeof options.ssr !== 'undefined') this.ssr = options.ssr;\n    CfDom._initialized = true;\n  }\n\n  /**\n   * Check if shim is properly configured.\n   */\n  private static ensureInitialized(): void {\n    if (!CfDom._initialized) {\n      CfDom.initialize();\n    }\n\n    CfDom.ensureAvailable(CfDom._document, 'document');\n    CfDom.ensureAvailable(CfDom._window, 'window');\n    CfDom.ensureAvailable(CfDom._HTMLElement, 'HTMLElement');\n  }\n\n  /**\n   * Throws an error if the specified object is not available.\n   */\n  private static ensureAvailable(obj: any, name: string): void {\n    if (!obj) {\n      throw new Error(`CfDom: ${name} is not available.` +\n        'Please configure CfDom with a valid DOM implementation.');\n    }\n  }\n\n  // Document methods\n  public static createElement(tagName: string): HTMLElement {\n    CfDom.ensureInitialized();\n    return CfDom._document!.createElement(tagName);\n  }\n\n  public static createDocumentFragment(): DocumentFragment {\n    CfDom.ensureInitialized();\n    return CfDom._document!.createDocumentFragment();\n  }\n\n  public static querySelector(selector: string, node?: ParentNode): Element | null {\n    CfDom.ensureInitialized();\n    const n = node ?? CfDom._document!;\n    return n.querySelector(selector);\n  }\n\n  public static querySelectorAll(selector: string, node?: ParentNode): NodeListOf<Element> {\n    CfDom.ensureInitialized();\n    const n = node ?? CfDom._document!;\n    return n.querySelectorAll(selector);\n  }\n\n  public static get body(): HTMLElement {\n    CfDom.ensureInitialized();\n    return CfDom._document!.body;\n  }\n\n  /**\n   * Add event listener with SSR protection\n   * This is one of the few element methods we keep as it has special SSR handling\n   */\n  public static addElEventListener(\n    el: EventTarget,\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: boolean | AddEventListenerOptions\n  ): void {\n    CfDom.ensureInitialized();\n    if (this.isSsr()) throw new Error(\"Event listeners are not available in SSR contexts!\");\n    el.addEventListener(type, listener, options);\n  }\n\n  // Additional helpers\n  public static isHTMLElement(obj: any): obj is HTMLElement {\n    CfDom.ensureInitialized();\n    return obj instanceof CfDom._HTMLElement!;\n  }\n\n  /**\n   * Check if code is running in a browser environment.\n   * This can be useful for conditional logic based on environment.\n   */\n  public static isBrowser(): boolean {\n    return typeof window !== 'undefined' && !!window.document;\n  }\n\n  /**\n   * Check if DOM shim is using a custom (non-browser) implementation.\n   */\n  public static isUsingCustomDOMImplementation(): boolean {\n    CfDom.ensureInitialized();\n    return CfDom._document !== null &&\n      (typeof window === 'undefined' || CfDom._document !== window.document);\n  }\n\n  public static isSsr(value?: boolean): boolean {\n    if (typeof value !== 'undefined') return this.ssr = value;\n    return this.ssr;\n  }\n}\n\n// Initialize on import\nCfDom.initialize();", "import type { ElementPosition } from \"../types.ts\";\nimport { CfDom } from \"./config.ts\";\nimport type { CfHTMLElementInterface } from './config.ts';\nexport { CfDom };\n\n/**\n * Inserts an element into the DOM given a reference element and the relative position\n * of the new element.\n * \n * * if `where` looks like `{ after: reference }`, the element is inserted into `reference`'s\n * parent, after `reference`.\n * * if `where` looks like `{ before: reference }`, the element is inserted into `reference`'s\n * parent, before `reference`.\n * * if `where` looks like `{ into: reference, at: 'start' }`, the element is inserted into \n * `reference`, before its first child.\n * * if `where` looks like `{ into: reference }`, the element is inserted into `reference`,\n * after its last child.\n * @param els The element(s) to insert.\n * @param where An object specifying where to insert `elem` relative to another element.\n * @throws an Error when there are no valid keys ('into', 'after', or 'before') present in `where`.\n * @returns the element that was inserted, so you can do `const a = insert(nu(), _)`.\n */\nexport const insert = (els: Element | Element[], where: ElementPosition) => {\n    // Check we have at least one valid key\n    if (!('into' in where) && !('after' in where) && !('before' in where)) {\n        throw new Error(\"No valid position specified. Use 'into', 'after', or 'before'.\");\n    }\n\n    let position: InsertPosition = 'beforeend';\n    let ref: CfHTMLElementInterface;\n\n    if ('after' in where) {\n        position = 'afterend';\n        ref = where.after;\n    } else if ('before' in where) {\n        position = 'beforebegin';\n        ref = where.before;\n    } else if ('into' in where && where.at === 'start') {\n        position = 'afterbegin';\n        ref = where.into;\n    } else {\n        ref = where.into;\n    }\n\n    const frag = CfDom.createDocumentFragment();\n    if (Array.isArray(els)) {\n        for (const item of els) frag.appendChild(item);\n    }\n    else {\n        frag.appendChild(els);\n    }\n\n    if (position === 'beforebegin') {\n        const parentNode = ref.parentNode;\n        if (parentNode) parentNode.insertBefore(frag, ref);\n    } else if (position === 'afterend') {\n        const parentNode = ref.parentNode;\n        if (parentNode) parentNode.insertBefore(frag, ref.nextSibling);\n    } else if (position === 'afterbegin') {\n        ref.insertBefore(frag, ref.firstChild);\n    } else {\n        ref.appendChild(frag);\n    }\n\n    return els;\n};\n\n/**\n * Fires a callback when the DOMContentLoaded event fires.\n * @param cb The callback to run.\n * @returns void\n */\nexport const onload = (cb: (ev: Event) => void) => globalThis.addEventListener('DOMContentLoaded', cb);\n\nexport type SelectParams = {\n    /** The selector to query for. */\n    s: string;\n    /** The parent node to query. Defaults to `document`. */\n    from?: ParentNode;\n    /** Whether to return all elements matching the given selector or just the first. */\n    all?: true;\n}\n\n/**\n * Queries the DOM for a particular selector, and returns the first element matching it.\n * @param opts See SelectParams.\n * @returns Element(s) matching the given selector, or an empty list.\n */\nexport function select(params: SelectParams & { single: true }): HTMLElement | null;\nexport function select(params: SelectParams & { single?: false }): HTMLElement[];\nexport function select({ s, all, from, single }: SelectParams & { single?: boolean }) {\n    const parent = (from ?? CfDom.document) as ParentNode;\n    if (all) {\n        return Array.from(CfDom.querySelectorAll(s, parent)) as HTMLElement[];\n    }\n\n    const elt = CfDom.querySelector(s, parent);\n    return single ? elt : [elt];\n}\n\n/**\n * Removes `elt` from the DOM.\n * @param elt The element to remove.\n * @returns void\n */\nexport const rm = (elt: Element) => elt.remove();\n\n/**\n * Empties a DOM element of its content.\n * @param elt The element to empty.\n */\nexport const empty = (elt: Element) => {\n    elt.innerHTML = '';\n};", "/**\n * a simple HTML sanitizer. Escapes `&`, `<`, `>`, `'`, and `\"` by \n * replacing them with their corresponding HTML escapes \n * (`&amp;`,`&gt;`, `&lt;`, `&#39;`, and `&quot`).\n * @param str A string to escape.\n * @returns The escaped string.\n * No characters other than the ones mentioned above are escaped.\n * `escape` is only provided for basic protection against XSS and if you need more\n * robust functionality consider using another HTML escaper (such as\n * [he](https://github.com/mathiasbynens/he) or \n * [sanitize-html](https://github.com/apostrophecms/sanitize-html)).\n */\nexport const escape = (str: string) => {\n    if (!str) return '';\n\n    return str.replace(/&/g, '&amp;')\n        .replace(/</g, '&lt;')\n        .replace(/>/g, '&gt;')\n        .replace(/\"/g, '&quot;')\n        .replace(/'/g, '&#39;');\n}\n\n/**\n * Unescapes the output of escape() by replacing `&amp;`, `&gt;`, `&lt;`,\n * `&#39;`, and `&quot` with `&`, `<`, `>`, `'`, and `\"` respectively.\n * @param str A string to unescape.\n * @returns The string, with its character references replaced by the characters it references.\n * No characters other than the ones mentioned above are unescaped.\n */\nexport const unescape = (str: string) => {\n    if (!str) return '';\n    const expr = /&(?:amp|lt|gt|quot|#(0+)?39);/g;\n\n    const entities: Record<string, string> = {\n        '&amp;': '&',\n        '&lt;': '<',\n        '&gt;': '>',\n        '&quot;': '\"',\n        '&#39;': \"'\"\n    };\n\n    return str.replace(expr, (entity) => entities[entity] || '\\'');\n}\n\nexport const seq = (...args: number[]) => {\n    let start = 0, stop = args[0], step = 1;\n    if (typeof args[1] !== 'undefined') {\n        start = args[0];\n        stop = args[1];\n    }\n\n    if (args[2]) step = args[2];\n    const result = [];\n    for (let i = start; i < stop; i += step) {\n        result.push(i);\n    }\n\n    return result;\n}\n\n/**\n * Represents a Node-style callback function that receives either an error or a result.\n * @template U The type of the successful result\n * @template E The type of the error\n */\nexport type Callback<U, E> = (err: E | null, res: U | null) => void;\n\n/**\n * Represents a function that accepts a callback as its first argument, followed by any other arguments.\n * @template T The types of the function arguments (excluding the callback)\n * @template U The type of the successful result passed to the callback\n * @template E The type of the error that might be passed to the callback\n */\nexport type Callbackified<T extends any[], U, E> = (cb: Callback<U, E>, ...args: T) => void;\n\n/**\n * Converts a function that returns a Promise into a function that accepts a Node-style callback.\n * \n * This utility helps integrate Promise-based code with callback-based APIs, including\n * using async operations in synchronous contexts like Store event handlers.\n * \n * @template T The types of the function arguments\n * @template U The type of the value that the Promise resolves to (default: unknown)\n * @template E The type of the error that might be caught (default: any)\n * \n * @param fn A function that returns a Promise\n * @returns A function that accepts a Node-style callback as its first argument\n * \n * @example\n * ```\n * // Using with Store event handlers (which expect synchronous functions)\n * // Instead of this (which uses async in a non-async context):\n * myStore.on('update', async (event) => {\n *   const data = await fetchDataFromApi(event.value);\n *   // Do something with data...\n * });\n * \n * // Do this instead:\n * const handleUpdateAsync = async (event) => {\n *   const data = await fetchDataFromApi(event.value);\n *   // Do something with data...\n * };\n * \n * myStore.on('update', (event) => {\n *   callbackify(handleUpdateAsync)(\n *     (err, _) => { if (err) console.error('Error:', err); },\n *     event\n *   );\n * });\n * ```\n */\nexport const callbackify = <T extends any[], U = unknown, E = any>(\n    fn: (...args: T) => Promise<U>\n): Callbackified<T, U, E> => {\n    return (cb, ...args) => {\n        fn(...args)\n            .then((v) => cb(null, v))\n            .catch(err => cb(err, null));\n    };\n}\n\n/**\n * Repeatedly executes a function at specified intervals.\n * \n * This utility provides a continuous polling mechanism with proper cleanup.\n * The function always schedules the next execution even if the current one throws an error.\n * \n * @param fn The function to execute repeatedly\n * @param interval Time in milliseconds between each execution\n * @param callNow Whether to execute the function immediately (default: false)\n * @returns A cancel function that stops the polling when called\n * \n * @example\n * ```\n * // Check for updates every 5 seconds\n * const stopPolling = poll(() => {\n *   checkForNewMessages();\n * }, 5000, true); // Start immediately\n * \n * // Later, when you want to stop polling:\n * stopPolling();\n * ```\n */\nexport const poll = (fn: () => void, interval: number, callNow = false) => {\n    let timeout: ReturnType<typeof setTimeout> | null = null;\n    const handler = () => {\n        try {\n            fn();\n        }\n        finally {\n            timeout = setTimeout(handler, interval);\n        }\n    }\n    if (callNow) handler();\n    else timeout = setTimeout(handler, interval);\n    return () => {\n        if (timeout !== null) clearTimeout(timeout);\n    }\n}\n\nconst generateId = (prefix: string) => `${prefix}-${Math.random().toString(36).slice(2, 8)}`;\n\n/**\n * Returns a function that generates random alphanumeric IDs with an optional prefix.\n * Each generated ID is unique within the scope of the returned function.\n * \n * Useful for creating unique HTML element IDs, form field IDs, or any scenario\n * where you need to generate multiple unique identifiers.\n * \n * Note: This function is not suitable for generating IDs that require\n * high entropy or cryptographic security.\n * \n * @example\n * ```ts\n * const genId = ids();\n * console.log(genId()) // cf-k9yh28\n * const todoId = ids('todo');\n * console.log(todoId()) // todo-hv9p4y\n * ```\n * @param prefix The prefix to use. Defaults to 'cf-'.\n * @returns A function that generates a unique ID.\n */\nexport const ids = (prefix = 'cf-') => {\n    const existing = new Set<string>();\n    return () => {\n        let id = generateId(prefix);\n        while (existing.has(id)) id = generateId(prefix);\n        existing.add(id);\n        return id;\n    }\n}\n\nexport const deepishClone = <T>(value: T, seen = new WeakMap()): T => {\n    // Handle primitives and functions (can't/shouldn't clone)\n    if (value === null || typeof value !== 'object') return value;\n    if (typeof value === 'function') return value;\n\n    // Handle cyclic references\n    if (seen.has(value)) return seen.get(value);\n\n    try {\n        if (Array.isArray(value)) {\n            const copy: any[] = [];\n            seen.set(value, copy);\n            for (const item of value) {\n                copy.push(deepishClone(item, seen));\n            }\n            return copy as T;\n        }\n\n        // Plain objects\n        if (Object.getPrototypeOf(value) === Object.prototype) {\n            const copy: Record<string, any> = {};\n            seen.set(value, copy);\n            for (const key in value) {\n                if (Object.hasOwn(value, key)) {\n                    copy[key] = deepishClone(value[key], seen);\n                }\n            }\n            return copy as T;\n        }\n\n        // Date, RegExp, Map, Set, etc \u2014 skip cloning, return reference\n        return value;\n\n    } catch (_) {\n        // Fallback on error (e.g., circular refs, DOM nodes, etc.)\n        return value;\n    }\n}", "import { escape } from '../utils.ts';\n\nexport interface RawHtml {\n    raw: true,\n    contents: string\n}\n\n/**\n * Options for r()\n */\nexport interface RawHtmlOptions {\n    joiner?: string;\n}\n\n/**\n * Prevent values from being escaped by html``.\n * @param val Any value.\n * @returns An object that tells html`` to not escape `val` while building the HTML string.\n */\nexport const r = (val: any, options?: RawHtmlOptions): RawHtml => {\n    return {\n        raw: true,\n        contents: Array.isArray(val) ?\n            val.join(options?.joiner ?? ' ') :\n            val.toString()\n    }\n}\n\n/**\n * Creates an HTML string with automatic escaping of interpolated values.\n * Use r() to prevent escaping specific values.\n * @param strings The constant portions of the template string.\n * @param values The dynamic values to be interpolated (automatically escaped unless wrapped with r()).\n * @returns The built HTML string with all values properly escaped.\n * @example\n * ```\n * const unsafe = `oops <script>alert(1)</script>`;\n * testing.innerHTML = html`foo bar baz ${unsafe}`; // Values are automatically escaped\n * const safeHtml = html`<div>${r(\"<b>Bold</b>\")}</div>`; // Using r() to prevent escaping\n * ```\n */\nexport const html = (strings: TemplateStringsArray, ...values: (string | boolean | number | RawHtml)[]) => {\n    const built = [];\n    for (let i = 0; i < strings.length; i++) {\n        built.push(strings[i] || '');\n        const val = values[i];\n        if (typeof val !== 'undefined' && typeof val !== 'object') {\n            built.push(escape((val ?? '').toString()));\n        }\n        else {\n            built.push(val?.contents || '');\n        }\n    }\n    return built.join('');\n}\n", "import { Store } from \"../stores/mod.ts\";\nimport type {\n    ElementProperties,\n    RenderFunction,\n    StringStyleProps,\n    TagStringParseResult,\n    DOMEventHandlers\n} from \"../types.ts\";\nimport { extend } from \"./nu.ts\";\nimport { CfDom } from \"./config.ts\";\nimport { html } from \"../templating/html.ts\";\nimport type { RawHtml } from \"../templating/html.ts\";\n\n/**\n * Creates a typed HTML element based on the tag name.\n * \n * @param name - The HTML tag name.\n * @returns A newly created HTML element of the specified type.\n * @internal\n */\nconst createTypedElement = <K extends keyof HTMLElementTagNameMap>(name: K) => {\n    return CfDom.createElement(name);\n}\n\n/** Creates a typed HTML element from an info string. */\nconst createElemFromInfo = (info: string) => {\n    let { tag, id, classes = [] } = parseEltString(info);\n\n    if (classes?.some((itm) => itm.includes('#'))) {\n        throw new Error(\n            \"Error: Found # in a class name. \" +\n            \"Did you mean to do elt#id.classes instead of elt.classes#id?\"\n        );\n    }\n\n    if (!tag) tag = 'div';\n    const elem = createTypedElement(tag as keyof HTMLElementTagNameMap);\n\n    if (id) elem.id = id;\n    if (classes?.length) classes.forEach(cls => elem.classList.add(cls));\n\n    return elem;\n}\n\n/**\n * Parses a tag string into its component parts.\n * \n * @param str A string to parse, of the form tag#id.classes[.classes].\n * @returns A `TagStringParseResult` object containing the parsed information.\n * @internal\n */\nconst parseEltString = (str: string | undefined): TagStringParseResult => {\n    const matches = str ? str.match(/([0-9a-zA-Z\\-]*)?(#[0-9a-zA-Z\\-]*)?((.[0-9a-zA-Z\\-]+)*)/) : undefined;\n    const results = matches ? matches.slice(1, 4)?.map((elem) => elem ? elem.trim() : undefined) : Array(3).fill(undefined);\n\n    if (results && results[1]) results[1] = results[1].replace(/#*/g, \"\");\n\n    return matches ? {\n        tag: results[0] || undefined,\n        id: results[1] || undefined,\n        classes: results[2] ? results[2].split('.').filter((elem: string) => elem.trim()) : undefined\n    } : {};\n};\n\n/**\n * Builder class for creating and configuring HTML elements using a fluent API.\n * \n * This class provides a chainable interface for configuring element properties\n * before creating the actual DOM element with the `done()` method.\n * \n * @example\n * ```typescript\n * // Create a button with multiple options\n * const [button] = nu('button#submit.primary')\n *   .content('Submit')\n *   .attr('type', 'submit')\n *   .on('click', () => console.log('Clicked!'))\n *   .style('backgroundColor', 'blue')\n *   .done();\n * ```\n */\nexport class NuBuilder<Elem extends HTMLElement, Deps extends Record<string, Store<any>>, Info = string> {\n    /** Element properties configuration object */\n    props: ElementProperties<Elem, Deps> = {};\n\n    /** Element info string (tag, id, classes) */\n    private elem: Elem;\n\n    /**\n     * Creates a new NuBuilder instance.\n     * \n     * @param info - A string describing the element in the format 'tag#id.class1.class2'\n     * @param props - Optional initial properties for the element\n     */\n    constructor(elt: Elem, props?: ElementProperties<Elem, Deps>);\n    constructor(elt: Info, props?: ElementProperties<Elem, Deps>);\n    constructor(elt: Info | Elem, props?: ElementProperties<Elem, Deps>);\n    constructor(elt: Info | Elem, props?: ElementProperties<Elem, Deps>) {\n        this.elem = (typeof elt === 'string' ? createElemFromInfo(elt) : elt) as Elem;\n        this.props = props || {};\n    }\n\n    /**\n     * Set a class name. Pass on with a falsy value to not apply the class.\n     * \n     * @param name - The class name to add/remove\n     * @param on - Whether the class should be applied (true) or removed (false/falsy)\n     * @returns The builder instance for chaining\n     */\n    cls(name: string, on: '' | boolean | 0 | null = true) {\n        this.props.classes ??= {};\n        this.props.classes[name] = !!on;\n        return this;\n    }\n\n    /**\n     * Finalizes the builder and creates the actual DOM element with all configured properties.\n     * \n     * @returns A tuple containing the created element as the first item, followed by any child elements\n     * @throws Error if a class name contains a '#' character\n     */\n    done(): [Elem, ...HTMLElement[]] {\n        return extend(this.elem as any as Elem, this.props);\n    }\n\n    ref() {\n        return this.done()[0];\n    }\n\n    /**\n     * Sets the content of the element as a string, escaped by default.\n     * Useful for quick and safe interpolation of strings into DOM content.\n     * \n     * @param value - String content to set\n     * @returns The builder instance for chaining\n     */\n    content(value: string) {\n        this.props.contents = value;\n        return this;\n    }\n\n    /**\n     * Sets a render function that will be called to generate content\n     * whenever dependencies change.\n     * \n     * @param fn - The render function that returns content\n     * @returns The builder instance for chaining\n     */\n    render(fn: RenderFunction<Elem, Deps>) {\n        this.props.render = fn;\n        return this;\n    }\n\n    /**\n     * Sets a single attribute on the element.\n     * \n     * @param name - The attribute name\n     * @param value - The attribute value. Set to empty string ('') to clear/reset an attribute.\n     * @returns The builder instance for chaining\n     */\n    attr(name: string, value: string | boolean | number) {\n        this.props.attrs ||= {};\n        this.props.attrs[name] = value.toString();\n        return this;\n    }\n\n    /**\n     * Sets multiple attributes on the element at once.\n     * \n     * @param value - An object containing attribute name-value pairs\n     * @returns The builder instance for chaining\n     */\n    attrs(value: ElementProperties<Elem, Deps>['attrs']) {\n        this.props.attrs = value;\n        return this;\n    }\n\n    /**\n     * Sets whether the content value should be treated as raw HTML.\n     * \n     * @param value - If true, content will not be escaped before setting innerHTML\n     * @returns The builder instance for chaining\n     */\n    raw(value: boolean) {\n        this.props.raw = value;\n        return this;\n    }\n\n    /**\n     * Sets miscellaneous properties on the element (e.g. `input.checked`).\n     * \n     * @param obj - Either a property name or an object containing multiple properties\n     * @param value - The value for the property if obj is a property name\n     * @returns The builder instance for chaining\n     */\n    misc(obj: string, value: unknown): NuBuilder<Elem, Deps, Info>;\n    misc(obj: Record<string, unknown>): NuBuilder<Elem, Deps, Info>;\n    misc(obj: string | Record<string, unknown>, value?: unknown): NuBuilder<Elem, Deps, Info> {\n        this.props.misc ||= {};\n        if (typeof obj === 'object') this.props.misc = obj;\n        else this.props.misc[obj] = value;\n        return this;\n    }\n\n    /**\n     * Sets a single CSS style property on the element.\n     * \n     * @param prop - The CSS property name\n     * @param value - The CSS property value. Set to empty string ('') to clear a style.\n     * @returns The builder instance for chaining\n     */\n    style(prop: StringStyleProps, value: string) {\n        this.props.style ||= {};\n        this.props.style[prop] = value;\n        return this;\n    }\n\n    /**\n     * Sets multiple CSS style properties on the element at once.\n     * \n     * @param value - An object containing style name-value pairs\n     * @returns The builder instance for chaining\n     */\n    styles(value: ElementProperties<Elem, Deps>['style']) {\n        this.props.style = value ?? {};\n        return this;\n    }\n\n    /**\n     * Attaches an event handler to the element.\n     * \n     * @param type - The event type to listen for (e.g., 'click', 'submit')\n     * @param handler - The event handler function\n     * @returns The builder instance for chaining\n     */\n    on<K extends keyof HTMLElementEventMap>(type: K, handler: (event: HTMLElementEventMap[K]) => void) {\n        this.props.on ||= {};\n        this.props.on[type] = handler as DOMEventHandlers[K];\n        return this;\n    }\n\n    /**\n     * Specifies selectors for elements that should be retrieved after building the element.\n     * \n     * @param selectors - A single selector string or an array of selector strings\n     * @returns The builder instance for chaining\n     */\n    gimme(...selectors: string[]) {\n        this.props.gimme ||= [];\n        this.props.gimme = selectors;\n        return this;\n    }\n\n    deps<ND extends Record<string, Store<any>>>(obj: ND): NuBuilder<Elem, Deps & ND, Info> {\n        this.props.deps = { ...(this.props.deps as Deps), ...obj };\n        return this as unknown as NuBuilder<Elem, Deps & ND, Info>;\n    }\n\n    /**\n     * Unsafely set the html of the object. This is equivalent to calling\n     * .content(...).raw(true) and is meant to be used with a templating function\n     * like `cf.html`.\n     * \n     * Can also be used as a templating function: nu().html`<b>${name}</b>` will\n     * cause name to be escaped and interpolated.\n     * @param value The string to set.\n     * @returns The builder for chaining.\n     */\n    html(value: string): NuBuilder<Elem, Deps, Info>;\n    html(arr: TemplateStringsArray, ...values: (string | number | boolean | RawHtml)[]): NuBuilder<Elem, Deps, Info>;\n    html(value: string | TemplateStringsArray, ...args: (string | boolean | number | RawHtml)[]): NuBuilder<Elem, Deps, Info> {\n        this.props.raw = true;\n        if (typeof value === 'string') {\n            this.props.contents = value;\n        }\n        else if (Array.isArray(value)) {\n            this.props.contents = html(value, ...args);\n        }\n        return this;\n    }\n\n    /**\n     * Mount reactive children into a parent element. The children are preserved\n     * across re-renders and can be independently reactive.\n     * @param children An object whose keys correspond to the `name` attributes \n     * of cf-slot elements in the parent's innerHTML.\n     * @returns The builder object for chaining.\n     */\n    children(children: Record<string, HTMLElement | HTMLElement[]>) {\n        this.props.children = children;\n        return this;\n    }\n\n    /**\n     * Mark the element for tracking, so it can be retrieved later by calling\n     * `cf.tracked(id)`.\n     * @param id The id to track the element by.\n     */\n    track(id: string) {\n        console.log(id);\n        this.props.track = id;\n        return this;\n    }\n}", "/**\n * Element tracking utility module\n * \n * This module provides a global registry for tracking DOM elements by custom identifiers.\n * It allows you to store references to elements and retrieve them from anywhere in your code.\n * Useful for creating routing systems, modal managers, or other scenarios where you need\n * to access specific elements across different parts of your application.\n */\n\nconst elements = new Map<string, HTMLElement>();\n\n/**\n * Track an element by an arbitrary string id. This is essentially a global \n * key-value store of elements you'd like to keep around.\n * \n * @example\n * ```ts\n * // Create and track elements\n * const header = document.createElement('header');\n * track('main-header', header);\n * \n * // Track dynamically created elements\n * const [sidebar] = nu('aside.sidebar').done();\n * track('app-sidebar', sidebar);\n * ```\n * \n * @param id An id to track the element by. This has to be unique across your\n * entire application.\n * @param elt The element to track.\n */\nexport const track = (id: string, elt: HTMLElement) => {\n    elements.set(id, elt);\n}\n\n/**\n * Stop tracking an element that was previously tracked by `track()`. If you're\n * calling track for thousands of elements it's probably a good idea to untrack\n * them when you're done.\n * \n * @example\n * ```ts\n * // Clean up when a component is removed\n * function removeComponent(id: string) {\n *   const element = tracked(id);\n *   if (element) {\n *     element.remove();\n *     untrack(id);\n *   }\n * }\n * ```\n * \n * @param id Id of the element to untrack, as passed to `track()`.\n */\nexport const untrack = (id: string) => {\n    elements.delete(id);\n}\n\n/**\n * Retrieve a tracked element by its id. Will return null if an element\n * corresponding to a given id is not found.\n * \n * @example\n * ```ts\n * // Access tracked elements from anywhere in your code\n * function showSidebar() {\n *   const sidebar = tracked('app-sidebar');\n *   if (sidebar) {\n *     sidebar.style.display = 'block';\n *   }\n * }\n * ```\n * \n * @param id The id of the tracked element to retrieve\n * @returns The tracked element, or null if not found\n */\nexport const tracked = (id: string) => {\n    return elements.get(id) || null;\n}", "import type { Store } from \"../stores/mod.ts\";\nimport type { ElementProperties, InferElementType, RenderBuilder, RenderFunction, UnwrapStore } from \"../types.ts\";\nimport type { CfHTMLElementInterface } from \"./config.ts\";\nimport { escape } from \"../utils.ts\";\nimport { select } from \"./mod.ts\";\nimport { NuBuilder } from \"./NuBuilder.ts\";\nimport { CfDom } from \"./config.ts\";\nimport type { StoreEventFromObject } from \"../types.ts\";\nimport * as tracking from './tracking.ts';\n\nconst unwrap = <D extends Record<string, Store<any>>>(\n    deps: D\n): UnwrapStore<D> => {\n    const result: any = {};\n    for (const key in deps) {\n        result[key] = deps[key].current();\n    }\n    return result;\n};\n\nconst isValidRenderFn = <T extends HTMLElement, D extends Record<string, Store<any>>>(\n    fn: ElementProperties<T, D>[\"render\"],\n): fn is RenderFunction<T, any> => {\n    if (!fn) return false;\n    if (typeof fn !== \"function\") return false;\n    return true;\n};\n\nconst reconcileClasses = (elt: HTMLElement, changed: Record<string, boolean>) => {\n    return Object.keys(changed).forEach(\n        key => changed[key] ? elt.classList.add(key) : elt.classList.remove(key)\n    );\n}\n\n/**\n * Reconciles the properties from a NuBuilder to an existing element.\n * This applies the builder's properties to the element without replacing it.\n * \n * @param elt The target element to update\n * @param builder The NuBuilder whose properties will be applied\n */\nconst reconcile = <\n    T extends HTMLElement,\n    D extends Record<string, Store<any>>\n>(elt: T, builder: RenderBuilder<T, D>) => {\n    const { style = {}, attrs = {}, misc = {}, classes = {} } = builder.props;\n    reconcileClasses(elt, classes);\n    Object.assign(elt.style, style);\n    if (attrs) {\n        Object.entries(attrs || {}).forEach(([key, value]) => {\n            if (typeof value === 'string' && value.length === 0) {\n                elt.removeAttribute(key);\n            }\n            else if (elt.getAttribute(key) !== String(value)) {\n                elt.setAttribute(key, String(value));\n            }\n        });\n    }\n    if (misc) Object.assign(elt, misc);\n    return elt;\n};\n\nconst extractReactiveChildren = (elt: HTMLElement) =>\n    select({ s: '[data-cf-slot]', all: true, from: elt })\n        .map(elt => [elt.getAttribute('data-cf-slot'), elt] as [string, HTMLElement])\n        .reduce((prev, [slot, elt]) => {\n            prev[slot] ??= [];\n            prev[slot].push(elt);\n            return prev;\n        }, {} as Record<string, HTMLElement[]>)\n\nconst setupDeps = <\n    T extends HTMLElement, D extends Record<string, Store<any>>\n>({ elt, render, deps }: {\n    elt: T,\n    render: RenderFunction<T, D>,\n    deps: D\n}) => {\n    Object.entries(deps).forEach(([name, dep]) => dep.any((evt) => {\n        const builder = new NuBuilder<T, D, string>(elt);\n        const res = render(unwrap(deps), {\n            elt,\n            event: { ...(evt as StoreEventFromObject<D>), triggeredBy: name },\n            b: builder as NuBuilder<T, any, string>,\n            first: false\n        });\n\n        const children = extractReactiveChildren(elt);\n        if (typeof res === 'string') {\n            elt.innerHTML = res;\n        }\n        else if (res instanceof NuBuilder) {\n            const c = res.props.contents || '';\n            elt.innerHTML = res.props.raw ? c : escape(c);\n            reconcile(elt, res);\n        }\n        else return;\n\n        for (const key in children) {\n            const [slot] = select({ s: `cf-slot[name='${key}']`, from: elt });\n            if (!slot) continue;\n            const list = children[key] || [];\n            const fragment = CfDom.createDocumentFragment();\n            list.forEach(elt => fragment.appendChild(elt))\n            slot.replaceWith(fragment);\n        }\n    })\n    );\n}\n\nconst setupReactiveChildren = <T extends HTMLElement>(\n    elt: T,\n    children: Record<string, CfHTMLElementInterface | CfHTMLElementInterface[]>\n) => {\n    elt.querySelectorAll('cf-slot[name]').forEach(itm => {\n        const name = itm.getAttribute('name');\n        if (!name) return;\n        if (Object.hasOwn(children, name)) {\n            const val = children[name];\n            const replacement: Node = Array.isArray(val) ?\n                CfDom.createDocumentFragment() : val;\n            if (Array.isArray(val)) val.forEach(item => {\n                replacement.appendChild(item);\n                item.setAttribute('data-cf-slot', name);\n            });\n            else val.setAttribute('data-cf-slot', name);\n            itm.replaceWith(replacement);\n        }\n    });\n}\n\n/**\n * Takes an existing element and modifies its properties.\n * Refer ElementProperties documentation for details on\n * what can be changed.\n * @param elt The element to modify.\n * @param args Properties to set on the element.\n */\nexport const extend = <\n    T extends HTMLElement,\n    D extends Record<string, Store<any>>,\n>(\n    elt: T,\n    args: ElementProperties<T, D> = {},\n): [T, ...HTMLElement[]] => {\n    const {\n        contents,\n        render,\n        misc,\n        style,\n        on = {},\n        attrs = {},\n        raw: r,\n        classes = {},\n        gimme = [],\n        deps = ({} as D),\n        children = {},\n        track\n    } = args;\n    let raw = !!r;\n\n    if (track) tracking.track(track, elt);\n    reconcileClasses(elt, classes);\n\n    const setHtml = (str: string) => elt.innerHTML = raw ? str : escape(str);\n\n    if (isValidRenderFn<T, D>(render)) {\n        setupDeps({ elt, render, deps });\n        const result = render(unwrap(deps), {\n            elt,\n            b: new NuBuilder<T, D, string>(elt),\n            first: true\n        });\n\n        if (typeof result === \"undefined\") elt.setAttribute(\"data-cf-fg-updates\", \"true\");\n        else {\n            elt.removeAttribute(\"data-cf-fg-updates\");\n            if (typeof result === 'string') {\n                setHtml(result);\n            }\n            if (result instanceof NuBuilder) {\n                raw = !!result.props.raw;\n                setHtml(result.props.contents || '');\n                reconcile(elt, result);\n            }\n        }\n    } else if (typeof contents === \"string\") {\n        setHtml(contents);\n    }\n\n    setupReactiveChildren(elt, children);\n\n    if (misc) Object.assign(elt, misc);\n    if (style) Object.assign(elt.style, style);\n\n    Object.entries(on)\n        .forEach(([evt, listener]) => CfDom.addElEventListener(elt, evt, listener as (evt: Event) => void));\n\n    Object.entries(attrs).forEach(([attr, value]) => {\n        const current = elt.getAttribute(attr);\n        const str = String(value);\n        if (current === str) return;\n        if (typeof value === 'string' && value.length === 0) elt.removeAttribute(attr);\n        else elt.setAttribute(attr, String(value));\n    });\n\n    const extras: HTMLElement[] = [];\n    for (const selector of gimme) {\n        const found = elt.querySelector(selector);\n        // This is on purpose.\n        // The user will expect the items to be at the same indices\n        // as the selectors they supplied.\n        extras.push(found as HTMLElement);\n    }\n\n    return [elt, ...extras];\n};\n\n/**\n * An element creation helper.\n * @param info Basic information about the element.\n * `eltInfo` should be a string of the format `tagName#id.class1.class2`.\n * Each part (tag name, id, classes) is optional, and an infinite number of\n * classes is allowed. When `eltInfo` is an empty string, the tag name is assumed to be\n * `div`.\n * @param args Optional extra properties for the created element.\n * @returns The newly created DOM element and any other elements requested in the\n * `gimme` parameter specified in args.\n * @example\n * ```\n * cf.nu(`elt#id.class1`, {\n *  raw: true,\n *  c: html`<span class=some-span>foo bar</span>`,\n *  gimme: ['.some-span']\n * }) // Output: [<elt#id.class1>, <the span some-span>]\n * ```\n * @example\n * ```\n * cf.nu(`span.some-span`, {\n *  // properties...\n *  // no gimme specified\n * }) // Output is still a list [<span.some-span>]\n * ```\n */\nexport const nu = <\n    const Info extends string,\n    Elem extends InferElementType<Info>,\n    Deps extends Record<string, Store<any>>,\n>(\n    elt = 'div' as Info | Elem,\n    args: ElementProperties<Elem, Deps> = {},\n): NuBuilder<Elem, Deps, Info> => {\n    return new NuBuilder<Elem, Deps, Info>(elt, args);\n};", "import type { EventSubscriber, EventType, StoreEvent, AnySubscriber } from \"../types.ts\";\nimport { ids, deepishClone } from \"../utils.ts\";\n\nconst storeId = ids('cf-store');\n\n/**\n * A simple reactive store.\n * @class Store\n * @public\n */\nexport class Store<T> {\n    /**\n     * A unique ID for the store, to track nested reactive elements to warn the user.\n     * @internal\n     */\n    id = storeId();\n\n    /**  \n     * The value of the store. \n     * @private As of 4.0.0-rc15, direct access is protected. Use current() instead.\n     */\n    protected value: T;\n    /** \n     * The subscribers currently registered to the store. \n     * @internal\n    */\n    _subscribers: {\n        [K in EventType]?: Record<number, EventSubscriber<K, Store<T>>>\n    } = {};\n    /** \n     * The subscribers currently registered to the store. \n     * @internal\n    */\n    _subscriberCounts: Record<string, number> = {};\n    /**\n     * A value describing whether or not the store has been disposed of.\n     * @internal\n     */\n    _dead = false;\n\n    /**\n     * Creates an instance of Store.\n     * @param value - The initial value of the store.\n     */\n    constructor(value: T) {\n        this.value = value;\n    }\n\n    /**\n     * Add an event listener to the store.\n     * @param type The type of event to listen for.\n     *   Supported event types include:\n     *   - `update`: Triggered when the store's value is updated via `update()`.\n     *   - `append`: For `ListStore` - Triggered when an item is added to the list.\n     *   - `deletion`: For `ListStore`/`MapStore` - Triggered when an item is removed.\n     *   - `change`: For `ListStore`/`MapStore`: Triggered when an item at an index/key\n     *     has its value set via the corresponding store's set() method.\n     *   - 'clear': Triggered when the store is cleared.\n     * @param fn A callback function that will be invoked when the specified event occurs.\n     *   The function receives a `StoreEvent` object with details about the event.\n     * @param callNow Optional parameter to immediately trigger the callback with current value\n     * @returns A unique subscriber ID that can be used to unsubscribe the listener.\n     * @example\n     * ```ts\n     * // Subscribe to updates\n     * const counter = store({ value: 0 });\n     * counter.on(\"update\", (event) => {\n     *   console.log(`Counter updated to: ${event.value}`);\n     * });\n     * \n     * // Subscribe and trigger immediately with current value\n     * counter.on(\"update\", (event) => {\n     *   console.log(`Current value: ${event.value}`);\n     * }, true);\n     * ```\n     */\n    on<K extends EventType>(type: K, fn: EventSubscriber<K, Store<T>>, callNow?: true): number {\n        this._subscriberCounts[type] ??= 0;\n        this._subscribers[type] ??= {};\n        const id = this._subscriberCounts[type]++;\n        this._subscribers[type][id] = fn;\n        // @ts-ignore this is not a problem\n        if (type === 'update' && callNow) fn({ type: 'update', value: this.value });\n        return this._subscriberCounts[type]++;\n    }\n\n    /**\n     * Subscribes the provided function to all store events.\n     * This is a convenience method that registers the function for 'change',\n     * 'append', 'clear', and 'deletion' events.\n     * \n     * @param fn A callback function that will be called for all store events\n     * @returns void\n     */\n    any(fn: AnySubscriber<Store<T>>) {\n        this.on('append', fn);\n        this.on('change', fn);\n        this.on('clear', fn);\n        this.on('deletion', fn);\n        this.on('update', fn);\n    }\n\n    /**\n     * Removes a specific event listener from the store.\n     * @param type The type of event from which to unsubscribe.\n     * @param id The subscriber ID returned by the `on()` method when the listener was registered.\n     * @throws Will throw an error if the subscriber ID is invalid or not found.\n     */\n    unsubscribe(type: EventType, id: number) {\n        delete this._subscribers[type]?.[id];\n    }\n\n    /**\n     * Utility method to check if a value is a transform function\n     * @internal\n     */\n    static isUpdater<T>(val: unknown): val is (arg: T) => T {\n        return typeof val === 'function';\n    }\n\n    /**\n     * Updates the store's value and notifies all subscribers.\n     * \n     * As of 4.0.0-rc15, this method can also accept a transform function that\n     * receives the current value and returns a new value.\n     * \n     * @param value The new value to set for the store, or a transform function\n     * that takes the current value and returns a new value.\n     * @returns The updated value, or null if the store has been disposed.\n     * @emits 'update' event with the new value when successfully updated.\n     * @example\n     * ```ts\n     * // Direct update\n     * counter.update(5);\n     * \n     * // Update using a transform function\n     * counter.update(current => current + 1);\n     * \n     * // Complex transform\n     * userStore.update(user => ({\n     *   ...user,\n     *   visits: user.visits + 1,\n     *   lastVisit: new Date()\n     * }));\n     * ```\n     */\n    update(value: (arg: T) => T): T | null;\n    update(value: T): T | null;\n    update(value: T | ((arg: T) => T)): T | null {\n        if (this._dead) return null;\n        let updated: T;\n        if (Store.isUpdater<T>(value)) {\n            updated = value(this.value);\n        }\n        else {\n            updated = value;\n        }\n        this.value = updated;\n        this._sendEvent({ type: 'update', value: Object.freeze(updated) });\n        return updated;\n    }\n\n    /**\n     * Sends an event to all subscribers if the store has not been disposed of.\n     * @internal\n    */\n    _sendEvent(event: StoreEvent<Store<T>>) {\n        if (this._dead) return;\n        const subs = this._subscribers[event.type] as Record<number, EventSubscriber<typeof event.type, Store<T>>>;\n        if (!subs) return;\n\n        for (const idx in subs) {\n            subs[idx](event);\n        }\n    }\n\n    /**\n     * Close the store so it no longer sends events.\n     */\n    dispose() {\n        this._dead = true;\n        this._subscribers = {};\n        this._subscriberCounts = {};\n    }\n\n    /**\n     * Get a deep clone of the current store value.\n     * \n     * Added in 4.0.0-rc15 as the recommended way to access store values\n     * since the value property is now protected.\n     * \n     * @returns A deep clone of the store's current value\n     * @example\n     * ```ts\n     * const user = store({ value: { name: \"John\", age: 30 } });\n     * const userData = user.current();  // { name: \"John\", age: 30 }\n     * ```\n     */\n    current() {\n        return deepishClone(this.value);\n    }\n\n    /**\n     * @deprecated Use current() instead\n     */\n    valueOf() {\n        return deepishClone(this.value);\n    }\n}", "import { Store } from \"./Store.ts\";\n\n/**\n    * A reactive list store.\n*/\nexport class ListStore<T> extends Store<T[]> {\n    constructor(ls?: T[]) {\n        super(ls || []);\n    }\n\n    /**\n     * Clears all elements from the store.\n     * @description Sets the store's value to an empty array and triggers a 'clear' event.\n     * @emits 'clear' event.\n     */\n    clear() {\n        this.value = [];\n        this._sendEvent({ type: \"clear\" });\n    }\n\n    /**\n     * Appends a new element to the end of the list.\n     * @param val The value to add to the list.\n     * @returns The new length of the list after appending.\n     * @emits 'append' event with:\n     *   - `value`: The appended item\n     *   - `idx`: The index where the item was inserted (length - 1)\n     */\n    push(val: T) {\n        this.value.push(val);\n        // Send a copy in the event\n        this._sendEvent({\n            type: \"append\",\n            value: Object.freeze(val),\n            idx: this.value.length - 1\n        });\n        return this.value.length;\n    }\n\n    /**\n     * Removes the element at the specified index.\n     * @param idx The index of the element to remove.\n     * @throws {RangeError} If the index is out of bounds.\n     * @emits 'deletion' event with:\n     *   - `value`: The removed item\n     *   - `idx`: The index from which the item was removed\n     */\n    remove(idx: number) {\n        if (idx < 0) return; // fail quietly incase findIndex() was passed\n        if (idx >= this.value.length) throw new RangeError(\"Invalid index.\");\n        this._sendEvent({\n            type: 'deletion',\n            idx,\n            value: this.value.splice(idx, 1)[0]\n        });\n    }\n\n    /**\n     * Retrieves the element at the specified index.\n     * @param idx The index of the element to retrieve.\n     * @returns The element at the specified index.\n     * @throws {RangeError} If the index is out of bounds.\n     */\n    get(idx: number) {\n        if (idx < 0 || idx >= this.value.length) throw new RangeError(\"Invalid index.\");\n        return Object.freeze(this.value[idx]);\n    }\n\n    /**\n     * Sets the value of an element at a specific index.\n     * @param idx The index of the element to modify.\n     * @param value The new value to set at the specified index.\n     * @throws {RangeError} If the index is out of bounds.\n     * @emits 'change' event with:\n     *   - `value`: The new value\n     *   - `idx`: The index of the modified element\n     */\n    set(idx: number, value: T) {\n        if (idx < 0 || idx >= this.value.length) throw new RangeError(\"Invalid index.\");\n        this.value[idx] = value;\n        // Send a copy in the event\n        this._sendEvent({\n            type: \"change\", value: Object.freeze(value), idx\n        });\n    }\n\n    [Symbol.iterator]() {\n        return this.value[Symbol.iterator]();\n    }\n\n    map: (...args: Parameters<T[]['map']>) => ReturnType<T[]['map']> = (...args) => {\n        return this.value.map(...args);\n    };\n\n    forEach: (...args: Parameters<T[]['forEach']>) => ReturnType<T[]['forEach']> = (...args) => {\n        return this.value.forEach(...args);\n    };\n\n\n    findIndex: (...args: Parameters<T[]['findIndex']>) => ReturnType<T[]['findIndex']> = (...args) => {\n        return this.value.findIndex(...args);\n    };\n\n    /**\n     * Utility accessor to find the length of the store.\n     */\n    get length() {\n        return this.value.length;\n    }\n}\n", "import { Store } from \"./Store.ts\";\n\n/**\n * A reactive map store.\n * Implements set(key, value), remove(key), clear(), transform(key, fn), has(key), entries(), \n * and get(key).\n * set() sends a \"change\" event, remove() sends a \"deletion\" event, clear() sends a \"clear\" event,\n * and transform() sends a \"change\" event.\n */\nexport class MapStore<T> extends Store<Record<string, T>> {\n\n    /**\n     * Constructor for MapStore.\n     * Initializes the store with the provided initial key-value pairs.\n     * @param init Initial key-value pairs to populate the store.\n     */\n    constructor(init?: Record<string, T>) {\n        super({});\n\n        if (!init) return;\n\n        for (const [k, v] of Object.entries(init)) {\n            this.value[k] = Object.freeze(v);\n        }\n    }\n\n    /**\n     * Sets a value for a specific key in the store.\n     * @param key The key to set or update.\n     * @param value The value to associate with the key.\n     * @emits 'change' event with:\n     *   - `key`: The key that was set or updated\n     *   - `value`: The new value associated with the key\n     */\n    set(key: string, value: T) {\n        this.value[key] = Object.freeze(value);\n        this._sendEvent({ key, value, type: 'change' });\n    }\n\n    /**\n     * Removes a key-value pair from the store.\n     * @param key The key to remove.\n     * @emits 'deletion' event with:\n     *   - `key`: The key that was removed\n     *   - `value`: The current state of the map after deletion\n     */\n    remove(key: string) {\n        const value = this.value[key];\n        if (value === null || typeof value === 'undefined') return;\n        delete this.value[key];\n        this._sendEvent({ key, value: value, type: 'deletion' });\n    }\n\n    /**\n     * Removes all key-value pairs from the store.\n     * @emits 'clear' event indicating the store has been emptied.\n     */\n    clear() {\n        this.value = {};\n        this._sendEvent({ type: 'clear' });\n    }\n\n    /**\n     * Applies a transformation function to the value of a specific key.\n     * @param key The key whose value will be transformed.\n     * @param fn A function that takes the current value and returns a new value.\n     * @throws {Error} If the key does not exist in the store.\n     * @emits 'change' event with the transformed value (via internal `set` method)\n     */\n    transform(key: string, fn: (val: T) => T) {\n        const old = this.value[key];\n        if (!old) throw new Error(`ERROR: key ${key} does not exist in store!`);\n        const transformed = Object.freeze(fn(old));\n        this.set(key, transformed);\n        this._sendEvent({ type: \"change\", value: transformed, key });\n    }\n\n    /**\n     * Retrieves the value associated with a specific key.\n     * @param key The key to look up.\n     * @returns The value associated with the key, or undefined if the key does not exist.\n     */\n    get(key: string) {\n        return this.value[key];\n    }\n\n    has(key: string): boolean {\n        return Object.hasOwn(this.value, key);\n    }\n\n    entries() {\n        return Object.entries(this.value);\n    }\n\n    get size() {\n        return Object.keys(this.value).length;\n    }\n}\n", "import { ListStore } from \"./ListStore.ts\";\nimport { MapStore } from \"./MapStore.ts\";\nimport { Store } from \"./Store.ts\";\n\nexport type StoreInitializer<T> =\n    | { type: 'list'; value?: Array<T> }\n    | { type: 'map'; value?: Record<string, T> }\n    | { value?: T };\n\nexport function store<T>(opts: { type: 'list'; value?: T[] }): ListStore<T>;\nexport function store<T>(opts: { type: 'map'; value?: Record<string, T> }): MapStore<T>;\nexport function store<T>(opts: { value: T }): Store<T>;\nexport function store<T>(opts: { value?: T }): Store<T | undefined>;\nexport function store<T>(opts: StoreInitializer<T>): Store<any> {\n    if ('type' in opts) {\n        if (opts.type === 'list') return new ListStore(opts.value);\n        if (opts.type === 'map') return new MapStore(opts.value);\n    }\n    return new Store(opts.value);\n}\n\nexport { Store, ListStore, MapStore };", "import { escape } from '../utils.ts';\n\n/**\n * Represents a plain text token in a mustache template\n */\ninterface TextToken {\n    type: 'text',\n    value: string\n};\n\n/**\n * Represents a section token (opening or closing) in a mustache template\n */\ntype SectionToken = { key: string } & ({\n    type: 'section-open';\n    inverted: boolean;\n} | {\n    type: 'section-close';\n});\n\n/**\n * Represents a variable token in a mustache template\n */\ninterface VariableToken {\n    type: 'var',\n    key: string,\n    unescaped: boolean;\n}\n\n/**\n * Union type for all possible mustache token types\n */\ntype MustacheToken = (SectionToken | TextToken | VariableToken);\n\n/**\n * Tokenizes a mustache template string into individual tokens\n * \n * @param template - The template string to tokenize\n * @returns An array of tokens representing the template\n */\nconst tokenize = (template: string) => {\n    const re = /\\\\?({{{\\s*([^}]+)\\s*}}}|{{[#^/]?\\s*([^}]+)\\s*}})/g;\n    let index = 0;\n    const tokens: MustacheToken[] = [];\n    let match = re.exec(template);\n\n    while (match !== null) {\n        const [chunk, mustache, unsafeKey, key] = match;\n        const escaped = chunk.startsWith('\\\\');\n        const tag = chunk.length > 2 ? chunk[2] : null;\n\n        if (index < match.index) {\n            tokens.push({ type: 'text', value: template.slice(index, match.index) });\n        }\n        if (escaped) {\n            tokens.push({ type: 'text', value: mustache });\n        }\n        else if (tag === '/') {\n            tokens.push({ type: 'section-close', key });\n        }\n        else if (tag === '#' || tag === '^') {\n            tokens.push({ type: 'section-open', key: key?.trim(), inverted: tag === '^' });\n        }\n        else {\n            tokens.push({ type: 'var', key: (unsafeKey || key)?.trim(), unescaped: !!unsafeKey });\n        }\n\n        index = re.lastIndex;\n        match = re.exec(template);\n    }\n\n    if (index < template.length) {\n        tokens.push({ type: 'text', value: template.slice(index) });\n    }\n\n    return tokens;\n}\n\n/**\n * Represents a compiled section in a mustache template\n */\ninterface CompiledSection {\n    type: 'section';\n    inverted: boolean;\n    key: string;\n    children: CompiledToken[]\n}\n\n/**\n * Union type for all compiled token types\n */\ntype CompiledToken = TextToken | VariableToken | CompiledSection\n\n/**\n * Transforms a flat array of tokens into a nested structure with proper section hierarchy\n * \n * @param tokens - The flat array of tokens to nest\n * @returns A nested token tree representing the template structure\n * @throws Error if sections are improperly nested or unclosed\n */\nfunction nest(tokens: MustacheToken[]) {\n    const root: CompiledToken[] = [];\n    const stack = [root];\n\n    for (const token of tokens) {\n        if (token.type === 'section-open') {\n            const section: CompiledSection = {\n                type: 'section',\n                key: token.key,\n                inverted: token.inverted,\n                children: []\n            };\n\n            stack.at(-1)?.push(section);\n            stack.push(section.children);\n        }\n        else if (token.type === 'section-close') {\n            if (stack.length === 1) throw new Error(`Unexpected closing tag ${token.key}`);\n            stack.pop();\n        }\n        else {\n            stack.at(-1)?.push(token);\n        }\n    }\n\n    if (stack.length > 1) {\n        throw new Error(`Unclosed section(s) found`);\n    }\n\n    return root;\n}\n\n/**\n * Compiles a mustache template string into a token tree\n * \n * @param template - The template string to compile\n * @returns A compiled token tree representing the template\n */\nconst compile = (template: string) => nest(tokenize(template));\n\n/**\n * Renders a compiled token tree with the provided context data\n * \n * @param tokens - The compiled token tree to render\n * @param ctx - The context object containing data for rendering\n * @param parentCtx - Optional parent context for nested rendering\n * @returns The rendered string result\n */\nconst render = <\n    T extends Record<string, any>\n>(tokens: CompiledToken[], ctx: T, parentCtx?: Record<string, any>): string => tokens.map(token => {\n    switch (token.type) {\n        case \"text\":\n            return token.value;\n        case \"var\": {\n            if (token.key === '.' && '.' in ctx) {\n                return token.unescaped\n                    ? String(ctx['.'])\n                    : escape(String(ctx['.']));\n            }\n\n            if (!(token.key in ctx)) {\n                return token.unescaped ? `{{{ ${token.key} }}}` : `{{ ${token.key} }}`;\n            }\n\n            const val = String(ctx[token.key]);\n            return token.unescaped ? val : escape(val);\n        }\n        case \"section\": {\n            const v = ctx[token.key];\n            let visible = !!v;\n\n            if (token.inverted) {\n                visible = (v === null || v === false || typeof v === 'undefined' ||\n                    (Array.isArray(v) && v.length === 0));\n            }\n\n            if (!visible) return '';\n            if (token.inverted) return render(token.children, ctx, parentCtx);\n\n            if (Array.isArray(v)) return v\n                .map(item => render(token.children, typeof item === 'object' ? item : { '.': item }, ctx)\n                ).join('');\n\n            else if (typeof v === 'object' && v !== null)\n                return render(token.children, v, ctx);\n            else\n                return render(token.children, ctx, parentCtx);\n        }\n    }\n}).join('');\n\n/**\n * Renders a mustache template with the provided context data.\n * \n * @param template - The template string to render\n * @param ctx - The context object containing data for rendering\n * @returns The rendered string result\n * \n * @example\n * ```js\n * const result = mustache(\"Hello, {{ name }}!\", { name: \"World\" });\n * // result: \"Hello, World!\"\n * ```\n * \n * @example Using sections\n * ```js\n * const result = mustache(\n *   \"{{#show}}Visible{{/show}} {{^hide}}Also Visible{{/hide}}\",\n *   { show: true, hide: false }\n * );\n * // result: \"Visible Also Visible\"\n * ```\n * \n * @example Using array iteration\n * ```js\n * const result = mustache(\n *   \"Items: {{#items}}{{name}}{{/items}}\",\n *   { items: [{ name: \"one\" }, { name: \"two\" }] }\n * );\n * // result: \"Items: onetwo\"\n * ```\n */\nexport const mustache = <\n    T extends Record<string, any> = Record<string, any>\n>(template: string, ctx: T): string => {\n    return render<T>(compile(template), ctx);\n}\n\n/**\n * Creates a reusable template function from a mustache template string.\n * \n * @param template - The template string to compile\n * @returns A function that accepts a context object and returns the rendered string\n * \n * @example\n * ```js\n * const greet = template(\"Hello, {{ name }}!\");\n * const result1 = greet({ name: \"Alice\" }); // \"Hello, Alice!\"\n * const result2 = greet({ name: \"Bob\" });   // \"Hello, Bob!\"\n * ```\n */\nexport const template = <\n    T extends Record<string, any> = Record<string, any>\n>(template: string): (ctx: T) => string => {\n    const compiled = compile(template);\n    return (ctx) => render<T>(compiled, ctx);\n}\n", "import { insert, empty, rm, select, onload } from \"./dom/mod.ts\"\nimport { extend, nu } from \"./dom/nu.ts\"\nimport { NuBuilder } from \"./dom/NuBuilder.ts\"\nimport { ListStore, MapStore, Store, store } from \"./stores/mod.ts\"\nimport { html, r } from \"./templating/html.ts\"\nimport { mustache, template } from \"./templating/mustache.ts\"\nimport { seq, escape, unescape, callbackify, poll, ids } from './utils.ts'\nimport { CfDom } from \"./dom/mod.ts\";\n\nimport type { SelectParams } from \"./dom/mod.ts\";\nimport type { RawHtmlOptions } from \"./templating/html.ts\";\nimport type { ElementPosition, ElementProperties, AnySubscriber, EventSubscriber, Template } from \"./types.ts\"\nimport type { Callback, Callbackified } from \"./utils.ts\";\nimport { track, tracked, untrack } from \"./dom/tracking.ts\";\n\nexport default {\n    ListStore,\n    MapStore,\n    Store,\n    store,\n    nu,\n    mustache,\n    template,\n    escape,\n    unescape,\n    extend,\n    insert,\n    empty,\n    rm,\n    select,\n    onload,\n    html,\n    r,\n    seq,\n    CfDom,\n    callbackify,\n    poll,\n    ids,\n    track,\n    tracked,\n    untrack\n}\n\nexport {\n    ListStore,\n    MapStore,\n    Store,\n    store,\n    nu,\n    mustache,\n    template,\n    escape,\n    unescape,\n    extend,\n    insert,\n    empty,\n    rm,\n    select,\n    onload,\n    html,\n    r,\n    seq,\n    CfDom,\n    callbackify,\n    poll,\n    ids,\n    track,\n    tracked,\n    untrack\n}\n\nexport type {\n    ElementPosition,\n    ElementProperties,\n    AnySubscriber,\n    EventSubscriber,\n    Template,\n    NuBuilder,\n    SelectParams,\n    RawHtmlOptions,\n    Callback,\n    Callbackified\n}"],
  "mappings": "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",
  "names": ["_CfDom", "options", "obj", "name", "tagName", "selector", "node", "el", "type", "listener", "value", "CfDom", "insert", "els", "where", "position", "ref", "frag", "CfDom", "item", "parentNode", "onload", "cb", "select", "s", "all", "from", "single", "parent", "elt", "rm", "empty", "escape", "str", "unescape", "expr", "entities", "entity", "seq", "args", "start", "stop", "step", "result", "i", "callbackify", "fn", "cb", "v", "err", "poll", "interval", "callNow", "timeout", "handler", "generateId", "prefix", "ids", "existing", "id", "deepishClone", "value", "seen", "copy", "item", "key", "r", "val", "options", "html", "strings", "values", "built", "i", "escape", "createTypedElement", "name", "CfDom", "createElemFromInfo", "info", "tag", "id", "classes", "parseEltString", "itm", "elem", "cls", "str", "matches", "results", "NuBuilder", "elt", "props", "on", "_a", "extend", "value", "fn", "obj", "prop", "type", "handler", "selectors", "args", "html", "children", "elements", "track", "id", "elt", "untrack", "tracked", "unwrap", "deps", "result", "key", "isValidRenderFn", "fn", "reconcileClasses", "elt", "changed", "reconcile", "builder", "style", "attrs", "misc", "classes", "value", "extractReactiveChildren", "select", "prev", "slot", "setupDeps", "render", "name", "dep", "evt", "NuBuilder", "res", "children", "c", "escape", "list", "fragment", "CfDom", "setupReactiveChildren", "itm", "val", "replacement", "item", "extend", "args", "contents", "on", "r", "gimme", "track", "raw", "setHtml", "str", "listener", "attr", "current", "extras", "selector", "found", "nu", "storeId", "ids", "Store", "_Store", "value", "type", "fn", "callNow", "_a", "_b", "id", "val", "updated", "event", "subs", "idx", "deepishClone", "ListStore", "Store", "ls", "args", "val", "idx", "value", "MapStore", "Store", "init", "k", "v", "key", "value", "fn", "old", "transformed", "store", "opts", "ListStore", "MapStore", "Store", "tokenize", "template", "re", "index", "tokens", "match", "chunk", "mustache", "unsafeKey", "key", "escaped", "tag", "nest", "root", "stack", "token", "section", "compile", "render", "ctx", "parentCtx", "escape", "val", "v", "visible", "item", "compiled", "campfire_default", "ListStore", "MapStore", "Store", "store", "nu", "mustache", "template", "escape", "unescape", "extend", "insert", "empty", "rm", "select", "onload", "html", "r", "seq", "CfDom", "callbackify", "poll", "ids", "track", "tracked", "untrack"]
}
