{
  "version": 3,
  "sources": ["../src/dom/mod.ts", "../src/utils.ts", "../src/dom/NuBuilder.ts", "../src/dom/nu.ts", "../src/stores/Store.ts", "../src/stores/ListStore.ts", "../src/stores/MapStore.ts", "../src/stores/mod.ts", "../src/templating/html.ts", "../src/templating/mustache.ts", "../src/campfire.ts"],
  "sourcesContent": ["import type { ElementPosition } from \"../types.ts\";\n\n/**\n * Inserts an element into the DOM given a reference element and the relative position\n * of the new element.\n * \n * * if `where` looks like `{ after: reference }`, the element is inserted into `reference`'s\n * parent, after `reference`.\n * * if `where` looks like `{ before: reference }`, the element is inserted into `reference`'s\n * parent, before `reference`.\n * * if `where` looks like `{ into: reference, at: 'start' }`, the element is inserted into \n * `reference`, before its first child.\n * * if `where` looks like `{ into: reference }`, the element is inserted into `reference`,\n * after its last child.\n * @param elems The elements to insert.\n * @param where An object specifying where to insert `elem` relative to another element.\n * @throws an Error when there are either zero or more than one keys present in `where`.\n * @returns the element that was inserted, so you can do `const a = insert(nu(), _)`.\n */\nexport const insert = (elems: Element[], where: ElementPosition) => {\n    const keys = Object.keys(where);\n    if (keys.length !== 1) {\n        throw new Error(\"Too many or too few positions specified.\");\n    }\n\n    let position: InsertPosition = 'beforeend';\n    let ref: Element;\n\n    if ('after' in where) {\n        position = 'afterend';\n        ref = where.after;\n    } else if ('before' in where) {\n        position = 'beforebegin';\n        ref = where.before;\n    } else if ('into' in where && where.at === 'start') {\n        position = 'afterbegin';\n        ref = where.into;\n    } else {\n        ref = where.into;\n    }\n\n    const frag = document.createDocumentFragment();\n    for (const item of elems) frag.appendChild(item);\n\n    if (position === 'beforebegin') {\n        ref.parentNode?.insertBefore(frag, ref);\n    } else if (position === 'afterend') {\n        ref.parentNode?.insertBefore(frag, ref.nextSibling);\n    } else if (position === 'afterbegin') {\n        ref.insertBefore(frag, ref.firstChild);\n    } else {\n        ref.appendChild(frag);\n    }\n\n    return elems;\n};\n\n/**\n * Fires a callback when the DOMContentLoaded event fires.\n * @param cb The callback to run.\n * @returns void\n */\nexport const onload = (cb: (ev: Event) => void) => globalThis.addEventListener('DOMContentLoaded', cb);\n\nexport interface SelectParams {\n    /** The selector to query for. */\n    s: string;\n    /** The parent node to query. Defaults to `document`. */\n    from?: ParentNode;\n    /** Whether to return all elements matching the given selector or just the first. */\n    all?: true;\n}\n\n/**\n * Queries the DOM for a particular selector, and returns the first element matching it.\n * @param opts See SelectParams.\n * @returns Element(s) matching the given selector, or an empty list.\n */\nexport const select = ({ s, all, from }: SelectParams) => {\n    from ??= document;\n    if (all) {\n        return Array.from(from.querySelectorAll(s)) as HTMLElement[];\n    }\n    else {\n        return [from.querySelector(s)] as HTMLElement[];\n    }\n}\n\n/**\n * Removes `elt` from the DOM.\n * @param elt The element to remove.\n * @returns void\n */\nexport const rm = (elt: Element) => elt.remove();\n\n/**\n * Empties a DOM element of its content.\n * @param elt The element to empty.\n */\nexport const empty = (elt: Element) => {\n    elt.innerHTML = '';\n};", "/**\n * a simple HTML sanitizer. Escapes `&`, `<`, `>`, `'`, and `\"` by \n * replacing them with their corresponding HTML escapes \n * (`&amp;`,`&gt;`, `&lt;`, `&#39;`, and `&quot`).\n * @param str A string to escape.\n * @returns The escaped string.\n * No characters other than the ones mentioned above are escaped.\n * `escape` is only provided for basic protection against XSS and if you need more\n * robust functionality consider using another HTML escaper (such as\n * [he](https://github.com/mathiasbynens/he) or \n * [sanitize-html](https://github.com/apostrophecms/sanitize-html)).\n */\nexport const escape = (str: string) => {\n    if (!str) return '';\n\n    return str.replace(/&/g, '&amp;')\n        .replace(/</g, '&lt;')\n        .replace(/>/g, '&gt;')\n        .replace(/\"/g, '&quot;')\n        .replace(/'/g, '&#39;');\n}\n\n/**\n * Unescapes the output of escape() by replacing `&amp;`, `&gt;`, `&lt;`,\n * `&#39;`, and `&quot` with `&`, `<`, `>`, `'`, and `\"` respectively.\n * @param str A string to unescape.\n * @returns The string, with its character references replaced by the characters it references.\n * No characters other than the ones mentioned above are unescaped.\n */\nexport const unescape = (str: string) => {\n    if (!str) return '';\n    const expr = /&(?:amp|lt|gt|quot|#(0+)?39);/g;\n\n    const entities: Record<string, string> = {\n        '&amp;': '&',\n        '&lt;': '<',\n        '&gt;': '>',\n        '&quot;': '\"',\n        '&#39;': \"'\"\n    };\n\n    return str.replace(expr, (entity) => entities[entity] || '\\'');\n}\n\nexport const seq = (...args: number[]) => {\n    let start = 0, stop = args[0], step = 1;\n    if (typeof args[1] !== 'undefined') {\n        start = args[0];\n        stop = args[1];\n    }\n\n    if (args[2]) step = args[2];\n    const result = [];\n    for (let i = start; i < stop; i += step) {\n        result.push(i);\n    }\n\n    return result;\n}\n\nconst fmtNode = (node: HTMLElement) => {\n    const result = ['<'];\n    result.push(node.tagName.toLowerCase());\n    if (node.id) result.push(`#${node.id}`);\n    if (node.className.trim()) result.push(`.${node.className.split(' ').join('.')}`);\n    result.push(...Array.from(node.attributes)\n        .map(attr => `${attr.name}=\"${attr.value}\"`)\n        .slice(0, 3) // limit to 3 attributes\n        .join(' '));\n    return result.join('');\n}\n\nexport const initMutationObserver = () => {\n    const observer = new MutationObserver((mutations) => {\n        for (const mutation of mutations) {\n            mutation.addedNodes.forEach(node => {\n                if (!(node instanceof HTMLElement)) return;\n\n                // Check parent is reactive\n                const parent = mutation.target as HTMLElement;\n                if (!parent.hasAttribute('data-cf-deps')) return;\n                if (parent.hasAttribute('data-cf-fg-updates')) return;\n\n                // Check if added node (or its children) are also reactive\n                const reactiveChildren = node.querySelectorAll?.('[data-cf-deps]').length ?? 0;\n                if (!node.hasAttribute?.('data-cf-deps') && reactiveChildren === 0) return;\n\n                console.warn(`[Campfire] \u26A0\uFE0F A reactive node ${fmtNode(node)} was inserted into a reactive ` +\n                    `container ${fmtNode(parent)} This may cause it to be wiped on re-render.`);\n\n            })\n        }\n    });\n\n    if (!document.body.hasAttribute('cf-disable-mo'))\n        observer.observe(document.body, { childList: true, subtree: true });\n}", "import { Store } from \"../stores/mod.ts\";\nimport type {\n    ElementProperties,\n    InferElementType,\n    RenderFunction,\n    StringStyleProps,\n    TagStringParseResult,\n    DOMEventHandlers\n} from \"../types.ts\";\nimport { extend } from \"./nu.ts\";\n\n\n/**\n * Creates a typed HTML element based on the tag name.\n * \n * @param name - The HTML tag name.\n * @returns A newly created HTML element of the specified type.\n * @internal\n */\nconst createTypedElement = <K extends keyof HTMLElementTagNameMap>(name: K) => {\n    return document.createElement(name);\n}\n\n/**\n * Parses a tag string into its component parts.\n * \n * @param str A string to parse, of the form tag#id.classes[.classes].\n * @returns A `TagStringParseResult` object containing the parsed information.\n * @internal\n */\nconst parseEltString = (str: string | undefined): TagStringParseResult => {\n    const matches = str ? str.match(/([0-9a-zA-Z\\-]*)?(#[0-9a-zA-Z\\-]*)?((.[0-9a-zA-Z\\-]+)*)/) : undefined;\n    const results = matches ? matches.slice(1, 4)?.map((elem) => elem ? elem.trim() : undefined) : Array(3).fill(undefined);\n\n    if (results && results[1]) results[1] = results[1].replace(/#*/g, \"\");\n\n    return matches ? {\n        tag: results[0] || undefined,\n        id: results[1] || undefined,\n        classes: results[2] ? results[2].split('.').filter((elem: string) => elem.trim()) : undefined\n    } : {};\n};\n\n/**\n * Builder class for creating and configuring HTML elements using a fluent API.\n * \n * This class provides a chainable interface for configuring element properties\n * before creating the actual DOM element with the `done()` method.\n * \n * @example\n * ```typescript\n * // Create a button with multiple options\n * const [button] = nu('button#submit.primary')\n *   .content('Submit')\n *   .attr('type', 'submit')\n *   .on('click', () => console.log('Clicked!'))\n *   .style('backgroundColor', 'blue')\n *   .done();\n * ```\n */\nexport class NuBuilder<T extends string, E extends InferElementType<T>, D extends Record<string, Store<any>>> {\n    /** Element properties configuration object */\n    props: ElementProperties<E, D> = {};\n\n    /** Element info string (tag, id, classes) */\n    info: T;\n\n    /**\n     * Creates a new NuBuilder instance.\n     * \n     * @param info - A string describing the element in the format 'tag#id.class1.class2'\n     * @param props - Optional initial properties for the element\n     */\n    constructor(info: T, props?: ElementProperties<E, D>) {\n        if (props) this.props = props;\n        this.info = info;\n    }\n\n    /**\n     * Finalizes the builder and creates the actual DOM element with all configured properties.\n     * \n     * @returns A tuple containing the created element as the first item, followed by any child elements\n     * @throws Error if a class name contains a '#' character\n     */\n    done(): [E, ...HTMLElement[]] {\n        let { tag, id, classes = [] } = parseEltString(this.info);\n\n        if (classes?.some((itm) => itm.includes('#'))) {\n            throw new Error(\n                \"Error: Found # in a class name. \" +\n                \"Did you mean to do elt#id.classes instead of elt.classes#id?\"\n            );\n        }\n\n        if (!tag) tag = 'div';\n        const elem = createTypedElement(tag as keyof HTMLElementTagNameMap);\n\n        if (id) elem.id = id;\n        classes.forEach((cls) => elem.classList.add(cls));\n\n        return extend(elem as E, this.props);\n    }\n\n    /**\n     * Sets the content of the element.\n     * \n     * @param value - Either a string of content or a render function that returns content\n     * @returns The builder instance for chaining\n     */\n    content(value: string | RenderFunction<E, D>) {\n        this.props.contents = value;\n        return this;\n    }\n\n    /**\n     * Sets a single attribute on the element.\n     * \n     * @param name - The attribute name\n     * @param value - The attribute value\n     * @returns The builder instance for chaining\n     */\n    attr(name: string, value: string | boolean | number) {\n        this.props.attrs ||= {};\n        this.props.attrs[name] = value.toString();\n        return this;\n    }\n\n    /**\n     * Sets multiple attributes on the element at once.\n     * \n     * @param value - An object containing attribute name-value pairs\n     * @returns The builder instance for chaining\n     */\n    attrs(value: ElementProperties<E, D>['attrs']) {\n        this.props.attrs = value;\n        return this;\n    }\n\n    /**\n     * Sets whether the content value should be treated as raw HTML.\n     * \n     * @param value - If true, content will not be escaped before setting innerHTML\n     * @returns The builder instance for chaining\n     */\n    raw(value: boolean) {\n        this.props.raw = value;\n        return this;\n    }\n\n    /**\n     * Sets miscellaneous properties on the element (e.g. `input.checked`).\n     * \n     * @param obj - Either a property name or an object containing multiple properties\n     * @param value - The value for the property if obj is a property name\n     * @returns The builder instance for chaining\n     */\n    misc(obj: string, value: unknown): NuBuilder<T, E, D>;\n    misc(obj: Record<string, unknown>): NuBuilder<T, E, D>;\n    misc(obj: string | Record<string, unknown>, value?: unknown): NuBuilder<T, E, D> {\n        this.props.misc ||= {};\n        if (typeof obj === 'object') this.props.misc = obj;\n        else this.props.misc[obj] = value;\n        return this;\n    }\n\n    /**\n     * Sets a single CSS style property on the element.\n     * \n     * @param prop - The CSS property name\n     * @param value - The CSS property value\n     * @returns The builder instance for chaining\n     */\n    style(prop: StringStyleProps, value: string) {\n        this.props.style ||= {};\n        this.props.style[prop] = value;\n        return this;\n    }\n\n    /**\n     * Sets multiple CSS style properties on the element at once.\n     * \n     * @param value - An object containing style name-value pairs\n     * @returns The builder instance for chaining\n     */\n    styles(value: ElementProperties<E, D>['style']) {\n        this.props.style = value ?? {};\n        return this;\n    }\n\n    /**\n     * Attaches an event handler to the element.\n     * \n     * @param type - The event type to listen for (e.g., 'click', 'submit')\n     * @param handler - The event handler function\n     * @returns The builder instance for chaining\n     */\n    on<K extends keyof HTMLElementEventMap>(type: K, handler: (event: HTMLElementEventMap[K]) => void) {\n        this.props.on ||= {};\n        this.props.on[type] = handler as DOMEventHandlers[K];\n        return this;\n    }\n\n    /**\n     * Specifies selectors for elements that should be retrieved after building the element.\n     * \n     * @param selectors - A single selector string or an array of selector strings\n     * @returns The builder instance for chaining\n     */\n    gimme(selectors: string | string[]) {\n        this.props.gimme ||= [];\n        if (Array.isArray(selectors)) this.props.gimme = selectors;\n        else this.props.gimme.push(selectors);\n        return this;\n    }\n\n    deps<ND extends Record<string, Store<any>>>(obj: ND): NuBuilder<T, E, D & ND> {\n        this.props.deps = { ...(this.props.deps as D), ...obj };\n        return this as unknown as NuBuilder<T, E, D & ND>;\n    }\n}", "import type { Store } from \"../stores/mod.ts\";\nimport type { ElementProperties, InferElementType, RenderFunction, UnwrapStore } from \"../types.ts\";\nimport { escape, initMutationObserver } from \"../utils.ts\";\nimport { NuBuilder } from \"./NuBuilder.ts\";\n\nif (\"MutationObserver\" in globalThis) initMutationObserver();\nelse {\n    console.warn(\n        \"MutationObserver was not found in your browser. Campfire will\",\n        \"not be able to warn you of destructive mutations!\",\n    );\n}\n\nconst unwrapDeps = <D extends Record<string, Store<any>>>(\n    deps: D\n): UnwrapStore<D> => {\n    const result: any = {};\n    for (const key in deps) {\n        const value = deps[key].value;\n        if (value instanceof Map) {\n            result[key] = Object.fromEntries(value.entries());\n        } else {\n            result[key] = value.valueOf();\n        }\n    }\n    return result;\n};\n\nconst isValidRenderFn = <T extends HTMLElement>(\n    fn: ElementProperties<T, any>[\"contents\"],\n): fn is RenderFunction<T, any> => {\n    if (!fn) return false;\n    if (typeof fn !== \"function\") return false;\n    return true;\n};\n\n/**\n * Takes an existing element and modifies its properties.\n * Refer ElementProperties documentation for details on\n * what can be changed.\n * @param elt The element to modify.\n * @param args Properties to set on the element.\n */\nexport const extend = <\n    T extends HTMLElement,\n    D extends Record<string, Store<any>> = {},\n>(\n    elt: T,\n    args: ElementProperties<T, D> = {},\n): [T, ...HTMLElement[]] => {\n    let { contents, misc, style, on = {}, attrs = {}, raw, gimme = [], deps = ({} as D) } = args;\n\n    let content = \"\";\n    if (isValidRenderFn<T>(contents)) {\n        Object.entries(deps).forEach(([name, dep]) => {\n            dep.any((evt) => {\n                const res = contents(unwrapDeps(deps), { event: { ...evt, triggeredBy: name }, elt });\n                if (res !== undefined) elt.innerHTML = res;\n            });\n        });\n\n        const result = contents(unwrapDeps(deps), { elt });\n\n        if (typeof result === \"undefined\") elt.setAttribute(\"data-cf-fg-updates\", \"true\");\n        else elt.removeAttribute(\"data-cf-fg-updates\");\n\n        content = result || \"\";\n    } else if (typeof contents === \"string\") {\n        content = contents;\n    }\n\n    if (content?.trim()) {\n        elt.innerHTML = raw ? content : escape(content);\n    }\n\n    const depIds = Object.values(deps).map((dep) => dep.id);\n    if (depIds.length) elt.setAttribute(\"data-cf-reactive\", \"true\");\n    else elt.removeAttribute(\"data-cf-reactive\");\n\n    if (misc) Object.assign(elt, misc);\n    if (style) Object.assign(elt.style, style);\n\n    Object.entries(on).forEach(([evt, listener]) => elt.addEventListener(evt, listener));\n\n    Object.entries(attrs).forEach(([attr, value]) => elt.setAttribute(attr, String(value)));\n\n    const extras: HTMLElement[] = [];\n    for (const selector of gimme) {\n        const found = elt.querySelector(selector);\n        // This is on purpose.\n        // The user will expect the items to be at the same indices\n        // as the selectors they supplied.\n        extras.push(found as HTMLElement);\n    }\n\n    return [elt, ...extras];\n};\n\n/**\n * An element creation helper.\n * @param info Basic information about the element.\n * `eltInfo` should be a string of the format `tagName#id.class1.class2`.\n * Each part (tag name, id, classes) is optional, and an infinite number of\n * classes is allowed. When `eltInfo` is an empty string, the tag name is assumed to be\n * `div`.\n * @param args Optional extra properties for the created element.\n * @returns The newly created DOM element and any other elements requested in the\n * `gimme` parameter specified in args.\n * @example\n * ```\n * cf.nu(`elt#id.class1`, {\n *  raw: true,\n *  c: html`<span class=some-span>foo bar</span>`,\n *  gimme: ['.some-span']\n * }) // Output: [<elt#id.class1>, <the span some-span>]\n * ```\n * @example\n * ```\n * cf.nu(`span.some-span`, {\n *  // properties...\n *  // no gimme specified\n * }) // Output is still a list [<span.some-span>]\n * ```\n */\nexport const nu = <\n    const T extends string,\n    E extends InferElementType<T>,\n    D extends Record<string, Store<any>> = {},\n>(\n    info: T = 'div' as T,\n    args: ElementProperties<E, D> = {},\n): NuBuilder<T, E, D> => {\n    return new NuBuilder<T, E, D>(info, args);\n};", "import type { StoreEvent, Subscriber } from \"../types.ts\";\n\nconst storeIds = new Set<string>();\nconst genId = () => 'cf-' + Math.random().toString(36).slice(2, 8);\n\nconst storeId = () => {\n    let id = genId();\n    while (storeIds.has(id)) id = genId();\n    storeIds.add(id);\n    return id;\n}\n\n/**\n * A simple reactive store.\n * @class Store\n * @public\n */\nexport class Store<T> {\n    /**\n     * A unique ID for the store, to track nested reactive elements to warn the user.\n     * @internal\n     */\n    id = storeId();\n\n    /**  The value of the store. */\n    value: T;\n    /** \n     * The subscribers currently registered to the store. \n     * @internal\n    */\n    _subscribers: {\n        [K in StoreEvent['type']]?: Record<number, Subscriber>;\n    } = {};\n    /** \n     * The subscribers currently registered to the store. \n     * @internal\n    */\n    _subscriberCounts: Record<string, number> = {};\n    /**\n     * A value describing whether or not the store has been disposed of.\n     * @internal\n     */\n    _dead = false;\n\n    /**\n     * Creates an instance of Store.\n     * @param value - The initial value of the store.\n     */\n    constructor(value?: T) {\n        if (typeof value !== 'undefined' && value !== null) this.value = value;\n    }\n\n    /**\n * Add an event listener to the store.\n * @param type The type of event to listen for.\n *   Supported event types include:\n *   - 'change': Triggered when the store's value is updated via `update()`.\n *   - 'append': For ListStore - Triggered when an item is added to the list.\n *   - 'deletion': For ListStore/MapStore - Triggered when an item is removed.\n *   - 'clear': Triggered when the store is cleared.\n * @param fn A callback function that will be invoked when the specified event occurs.\n *   The function receives a `StoreEvent` object with details about the event.\n * @param callNow Determines whether the callback should be immediately invoked \n *   with the current store value. Only applies to 'change' event type.\n * @returns A unique subscriber ID that can be used to unsubscribe the listener.\n */\n    on(type: StoreEvent['type'], fn: Subscriber, callNow: boolean = false): number {\n        this._subscriberCounts[type] = this._subscriberCounts[type] || 0;\n        this._subscribers[type] ??= {};\n        this._subscribers[type]![this._subscriberCounts[type]] = fn;\n        if (callNow && ![\"push\", \"remove\", \"mutation\", \"setAt\"].includes(type)) {\n            fn({ type: 'change', value: this.value });\n        }\n        return this._subscriberCounts[type]++;\n    }\n\n    /**\n         * Subscribes the provided function to all store events.\n         * This is a convenience method that registers the function for 'change',\n         * 'append', 'clear', and 'deletion' events.\n         * \n         * @param fn A callback function that will be called for all store events\n         * @returns void\n         */\n    any(fn: Subscriber) {\n        this.on('append', fn);\n        this.on('change', fn);\n        this.on('clear', fn);\n        this.on('deletion', fn);\n    }\n\n    /**\n     * Removes a specific event listener from the store.\n     * @param type The type of event from which to unsubscribe.\n     * @param id The subscriber ID returned by the `on()` method when the listener was registered.\n     * @throws Will throw an error if the subscriber ID is invalid or not found.\n     */\n    unsubscribe(type: StoreEvent['type'], id: number) {\n        delete this._subscribers[type]?.[id];\n    }\n\n    /**\n     * Updates the store's value and notifies all subscribers.\n     * @param value The new value to set for the store.\n     * @emits 'change' event with the new value when successfully updated.\n     * @note No-op if the store has been disposed via `dispose()`.\n     */\n    update(value: T) {\n        if (this._dead) return;\n        this.value = value;\n        this._sendEvent({ type: 'change', value });\n    }\n\n    /**\n     * Sends an event to all subscribers if the store has not been disposed of.\n     * @internal\n    */\n    _sendEvent(event: StoreEvent) {\n        if (this._dead) return;\n        this._subscribers[event.type] = this._subscribers[event.type] || {};\n        const subs = this._subscribers[event.type];\n        if (!subs) return;\n        for (const idx in Object.keys(subs)) {\n            subs[idx](event);\n        }\n    }\n\n    /**\n     * Close the store so it no longer sends events.\n     */\n    dispose() {\n        this._dead = true;\n        this._subscribers = {};\n        this._subscriberCounts = {};\n    }\n\n    valueOf() {\n        return structuredClone(this.value);\n    }\n}", "import { Store } from \"./Store.ts\";\n\n/**\n    * A reactive list store. \n    * Implements push(item). remove(idx), get(idx), and setAt(idx, item).\n    * push() sends an \"append\" event\n    * remove() sends a \"deletion\" event\n    * setAt() sends a \"change\" event with idx\n*/\nexport class ListStore<T> extends Store<T[]> {\n    constructor(ls?: T[]) {\n        super(ls);\n    }\n\n    /**\n     * Clears all elements from the store.\n     * @description Sets the store's value to an empty array and triggers a 'clear' event.\n     * @emits 'clear' event.\n     */\n    clear() {\n        this.value = [];\n        this._sendEvent({ type: \"clear\" });\n    }\n\n    /**\n     * Appends a new element to the end of the list.\n     * @param val The value to add to the list.\n     * @returns The new length of the list after appending.\n     * @emits 'append' event with:\n     *   - `value`: The appended item\n     *   - `idx`: The index where the item was inserted (length - 1)\n     */\n    push(val: T) {\n        this.value.push(val);\n        this._sendEvent({ type: \"append\", value: val, idx: this.value.length - 1 });\n        return this.value.length;\n    }\n\n    /**\n     * Removes the element at the specified index.\n     * @param idx The index of the element to remove.\n     * @throws {RangeError} If the index is out of bounds.\n     * @emits 'deletion' event with:\n     *   - `value`: The removed item\n     *   - `idx`: The index from which the item was removed\n     */\n    remove(idx: number) {\n        if (idx < 0 || idx >= this.value.length) throw new RangeError(\"Invalid index.\");\n        this._sendEvent({\n            type: 'deletion',\n            idx,\n            value: this.value.splice(idx, 1)[0]\n        });\n    }\n\n    /**\n     * Retrieves the element at the specified index.\n     * @param idx The index of the element to retrieve.\n     * @returns The element at the specified index.\n     * @throws {RangeError} If the index is out of bounds.\n     */\n    get(idx: number) {\n        if (idx < 0 || idx >= this.value.length) throw new RangeError(\"Invalid index.\");\n        return this.value[idx];\n    }\n\n    /**\n     * Sets the value of an element at a specific index.\n     * @param idx The index of the element to modify.\n     * @param value The new value to set at the specified index.\n     * @throws {RangeError} If the index is out of bounds.\n     * @emits 'change' event with:\n     *   - `value`: The new value\n     *   - `idx`: The index of the modified element\n     */\n    set(idx: number, value: T) {\n        if (idx < 0 || idx >= this.value.length) throw new RangeError(\"Invalid index.\");\n        this.value[idx] = value;\n        this._sendEvent({ type: \"change\", value, idx });\n    }\n\n    /**\n     * Utility accessor to find the length of the store.\n     */\n    get length() {\n        return this.value.length;\n    }\n}\n", "import { Store } from \"./Store.ts\";\n\n/**\n * A reactive map store.\n * Implements set(key, value), remove(key), clear(), transform(key, fn), has(key), entries(), \n * and get(key).\n * set() sends a \"change\" event, remove() sends a \"deletion\" event, clear() sends a \"clear\" event,\n * and transform() sends a \"change\" event.\n */\nexport class MapStore<T> extends Store<Map<string, T>> {\n\n    /**\n     * Constructor for MapStore.\n     * Initializes the store with the provided initial key-value pairs.\n     * @param init Initial key-value pairs to populate the store.\n     */\n    constructor(init?: Record<string, T>) {\n        super(new Map());\n\n        // Populates the store with initial key-value pairs.\n        for (const [k, v] of Object.entries(init || {})) {\n            this.value.set(k, v);\n        }\n    }\n\n    /**\n     * Sets a value for a specific key in the store.\n     * @param key The key to set or update.\n     * @param value The value to associate with the key.\n     * @emits 'change' event with:\n     *   - `key`: The key that was set or updated\n     *   - `value`: The new value associated with the key\n     */\n    set(key: string, value: T) {\n        this.value.set(key, value);\n        this._sendEvent({ key, value, type: 'change' });\n    }\n\n    /**\n     * A no-operation method for MapStore to maintain base Store compatibility.\n     * Does not perform any action.\n     * @deprecated\n     */\n    update() {\n        // Intentionally left as a no-op for MapStore\n    }\n\n    /**\n     * Removes a key-value pair from the store.\n     * @param key The key to remove.\n     * @emits 'deletion' event with:\n     *   - `key`: The key that was removed\n     *   - `value`: The current state of the map after deletion\n     */\n    remove(key: string) {\n        this.value.delete(key);\n        this._sendEvent({ key, value: this.value, type: 'deletion' });\n    }\n\n    /**\n     * Removes all key-value pairs from the store.\n     * @emits 'clear' event indicating the store has been emptied.\n     */\n    clear() {\n        this.value = new Map();\n        this._sendEvent({ type: 'clear' });\n    }\n\n    /**\n     * Applies a transformation function to the value of a specific key.\n     * @param key The key whose value will be transformed.\n     * @param fn A function that takes the current value and returns a new value.\n     * @throws {Error} If the key does not exist in the store.\n     * @emits 'change' event with the transformed value (via internal `set` method)\n     */\n    transform(key: string, fn: (val: T) => T) {\n        const old = this.value.get(key);\n        if (!old) throw new Error(`ERROR: key ${key} does not exist in store!`);\n        const transformed = fn(old);\n        this.set(key, transformed);\n        this._sendEvent({ type: \"change\", value: transformed, key });\n    }\n\n    /**\n     * Retrieves the value associated with a specific key.\n     * @param key The key to look up.\n     * @returns The value associated with the key, or undefined if the key does not exist.\n     */\n    get(key: string) {\n        return this.value.get(key);\n    }\n\n    has(key: string): boolean {\n        return this.value.has(key);\n    }\n\n    entries() {\n        return this.value.entries();\n    }\n}\n", "import { ListStore } from \"./ListStore.ts\";\nimport { MapStore } from \"./MapStore.ts\";\nimport { Store } from \"./Store.ts\";\n\nexport type StoreInitializer<T> =\n    | { type: 'list'; value?: Array<T> }\n    | { type: 'map'; value?: Record<string, T> }\n    | { value?: T };\n\nexport function store<T>(opts: { type: 'list'; value?: T[] }): ListStore<T>;\nexport function store<T>(opts: { type: 'map'; value?: Record<string, T> }): MapStore<T>;\nexport function store<T>(opts: { value?: T }): Store<T>;\nexport function store<T>(opts: StoreInitializer<T>): Store<any> {\n    if ('type' in opts) {\n        if (opts.type === 'list') return new ListStore(opts.value);\n        if (opts.type === 'map') return new MapStore(opts.value);\n    }\n    return new Store<T>(opts.value);\n}\nexport { Store, ListStore, MapStore };", "import { escape } from '../utils.ts';\n\nexport interface RawHtml {\n    raw: true,\n    contents: string\n}\n\n/**\n * Options for r()\n */\nexport interface RawHtmlOptions {\n    joiner?: string;\n}\n\n/**\n * Prevent values from being escaped by html``.\n * @param val Any value.\n * @returns An object that tells html`` to not escape `val` while building the HTML string.\n */\nexport const r = (val: any, options?: RawHtmlOptions): RawHtml => {\n    return {\n        raw: true,\n        contents: Array.isArray(val) ?\n            val.join(options?.joiner ?? ' ') :\n            val.toString()\n    }\n}\n\n/**\n * Creates an HTML string with automatic escaping of interpolated values.\n * Use r() to prevent escaping specific values.\n * @param strings The constant portions of the template string.\n * @param values The dynamic values to be interpolated (automatically escaped unless wrapped with r()).\n * @returns The built HTML string with all values properly escaped.\n * @example\n * ```\n * const unsafe = `oops <script>alert(1)</script>`;\n * testing.innerHTML = html`foo bar baz ${unsafe}`; // Values are automatically escaped\n * const safeHtml = html`<div>${r(\"<b>Bold</b>\")}</div>`; // Using r() to prevent escaping\n * ```\n */\nexport const html = (strings: TemplateStringsArray, ...values: (string | number | RawHtml)[]) => {\n    const built = [];\n    for (let i = 0; i < strings.length; i++) {\n        built.push(strings[i] || '');\n        let val = values[i];\n        if (typeof val !== 'undefined' && typeof val !== 'object') {\n            built.push(escape((val || '').toString()));\n        }\n        else {\n            built.push(val?.contents || '');\n        }\n    }\n    return built.join('');\n}\n", "import { escape } from '../utils.ts';\nimport type { Template } from '../types.ts';\n\n/**\n * The function that actually does the mustache templating.\n * @param string - the string to be templated.\n * @param data - The replacement data.\n * @internal\n * @returns the templated string.\n*/\nconst _mustache = (string: string, data: Record<string, string> = {}): string => {\n    const escapeExpr = new RegExp(\"\\\\\\\\({{\\\\s*\" + Object.keys(data).join(\"|\") + \"\\\\s*}})\", \"gi\");\n    new RegExp(Object.keys(data).join(\"|\"), \"gi\");\n    return string.replace(new RegExp(\"(^|[^\\\\\\\\]){{\\\\s*(\" + Object.keys(data).join(\"|\") + \")\\\\s*}}\", \"gi\"), function (matched, p1, p2) {\n        return `${p1 || \"\"}${data[p2]}`;\n    }).replace(escapeExpr, '$1');\n}\n\n/**\n * Applies mustache templating to a string. Any names surrounded by {{ }} will be\n * considered for templating: if the name is present as a property in `data`,\n * the mustache'd expression will be replaced with the value of the property in `data`.\n * Prefixing the opening {{ with double backslashes will escape the expression.\n * By default, mustache data is escaped with campfire's escape() function - you can\n * disable this by supplying the value of `esc` as false.\n * @param string - the string to be templated.\n * @param data - The data which will be used to perform replacements.\n * @param shouldEscape - Whether or not the templating data should be escaped. Defaults to true.\n * @returns the templated string.\n*/\nexport const mustache = (string: string, data: Record<string, string> = {}, shouldEscape = true): string => {\n    let escaped = { ...data };\n\n    if (shouldEscape) {\n        escaped = Object.fromEntries(Object.entries(escaped).map(([key, value]) => {\n            return [key, escape(value)]\n        }));\n    }\n\n    return _mustache(string, escaped);\n}\n\n/**\n * Returns a partial application that can be used to generate templated HTML strings.\n * Does not sanitize html, use with caution.\n * @param str - A string with mustaches in it. (For example: \n * `<span class='name'> {{ name }} </span>`)\n * @param shouldEscape - Whether or not the templating data should be escaped. Defaults to true.\n * @returns A function that when passed an Object with templating data,\n * returns the result of the templating operation performed on the string str with\n * the data passed in.\n */\nexport const template = (str: string, shouldEscape = true): Template => {\n    return (data: Record<string, string>) => mustache(str, data, shouldEscape);\n}\n", "import { insert, empty, rm, select, onload } from \"./dom/mod.ts\"\nimport { extend, nu } from \"./dom/nu.ts\"\nimport { NuBuilder } from \"./dom/NuBuilder.ts\"\nimport { ListStore, MapStore, Store, store } from \"./stores/mod.ts\"\nimport { html, r } from \"./templating/html.ts\"\nimport { mustache, template } from \"./templating/mustache.ts\"\nimport { seq, escape, unescape } from './utils.ts'\n\nimport type { SelectParams } from \"./dom/mod.ts\";\nimport type { RawHtmlOptions } from \"./templating/html.ts\";\nimport type { ElementPosition, ElementProperties, Subscriber, Template } from \"./types.ts\"\n\nexport default {\n    ListStore, MapStore, Store, store, nu, mustache, template, escape, unescape, extend, insert, empty, rm, select, onload, html, r, seq\n}\n\nexport {\n    ListStore, MapStore, Store, store, nu, mustache, template, escape, unescape, extend, insert, empty, rm, select, onload, html, r, seq\n}\n\nexport type {\n    ElementPosition, ElementProperties, Subscriber, Template, NuBuilder, SelectParams, RawHtmlOptions\n}"],
  "mappings": "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",
  "names": []
}
