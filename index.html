<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>campfire: a cozy web framework</title>
    <link rel="stylesheet" href="site/style.css">
    <link rel="shortcut icon" type="image/jpg" href="campfire.png" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@400;700&display=swap" rel="stylesheet">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.32.6/ace.min.js"></script>
    <script src="https://ace.c9.io/build/src/theme-tomorrow_night_blue.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.32.6/mode-html.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.32.6/mode-css.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.32.6/mode-javascript.min.js"></script>
</head>

<body>
    <div id='app'>
        <h1>campfire</h1>
        <noscript>
            I'd love to make this site work without JS enabled, but seeing as how this is meant to be a demonstration
            for a JS framework... you'll have to turn on scripts. Sorry for the inconvenience.
        </noscript>

        &lt;div class=&quot;cf-site-div&quot; data-heading=&quot;home&quot;&gt;&lt;h3&gt;campfire: a cozy web framework&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Campfire&lt;/strong&gt; is a collection of small utilities to make developing with vanilla
JS easy.&lt;/p&gt;
&lt;p&gt;It is kept lightweight on purpose, aiming to provide the bare minimum necessary
to make development easier.&lt;/p&gt;
&lt;h4&gt;Features&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Small size, zero dependencies&lt;/strong&gt;: 5kb compressed, no external dependencies&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Fluent Builder API&lt;/strong&gt;: Create and configure DOM elements with a chainable
syntax:&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;const [button] = cf.nu(&amp;quot;button#submit&amp;quot;)
  .content(&amp;quot;Click me&amp;quot;)
  .attr(&amp;quot;type&amp;quot;, &amp;quot;submit&amp;quot;)
  .on(&amp;quot;click&amp;quot;, handleClick)
  .done();
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Reactive Data System&lt;/strong&gt;: Create reactive stores with automatic UI updates:&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;// Create different types of stores
const name = cf.store({ value: &amp;quot;John&amp;quot; });
const reactiveList = cf.store({ type: &amp;quot;list&amp;quot;, value: [1, 2, 3] });
const reactiveMap = cf.store({ type: &amp;quot;map&amp;quot;, value: { key: &amp;quot;value&amp;quot; } });

// Use stores with reactive elements
const [div] = cf.nu(&amp;quot;div&amp;quot;)
  .content(({ name }) =&amp;gt;
    `Hello, ${name}! My favourite numbers are ${reactiveList.join(&amp;quot;,&amp;quot;)}`
  )
  .deps({ name, reactiveList })
  .done();

// Or do your own thing!
name.on(&amp;quot;change&amp;quot;, ({ value }) =&amp;gt; {
  greet(value);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Enhanced DOM Helpers&lt;/strong&gt;: Easy-to-use DOM manipulation utilities:&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;// Select elements (always returns an array)
const [button] = cf.select({ s: &amp;quot;#submit-button&amp;quot; });
const allButtons = cf.select({ s: &amp;quot;button&amp;quot;, all: true });

// Insert elements
cf.insert([elt], { into: container });
cf.insert([elt], { into: container, at: &amp;quot;start&amp;quot; });
cf.insert([elt], { before: sibling });
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TypeScript Support&lt;/strong&gt;: First-class TypeScript integration with type inference
for HTML elements&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;FAQs&lt;/h4&gt;
&lt;details&gt;
&lt;summary&gt;How does it compare to $framework?&lt;/summary&gt;

&lt;p&gt;It doesn&amp;#39;t. Campfire and $framework have entirely different goals. Campfire is a
library to make writing vanilla JS applications easier, if you don&amp;#39;t want the
level of abstraction (or the associated overhead) that comes with $framework.
You can build entire applications with it or add it quickly to an existing
project. You are afforded complete control over your project.&lt;/p&gt;
&lt;p&gt;The learning curve is minuscule and the possibilities are endless.&lt;/p&gt;
&lt;/details&gt;

&lt;details&gt;
&lt;summary&gt;What about WebComponents?&lt;/summary&gt;

&lt;p&gt;&lt;a href=&quot;https://lit.dev&quot;&gt;lit.dev&lt;/a&gt;&lt;/p&gt;
&lt;/details&gt;

&lt;details&gt;
&lt;summary&gt;How do I create and share reusable components?&lt;/summary&gt;

&lt;p&gt;Campfire has no opinion on how you should do this. However, one option is to use
a function that returns functions and stores to let you manipulate the element
(and the created element itself).&lt;/p&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;// a reactive representation of a name badge
const NameBadge = () =&amp;gt; {
  const name = cf.store({ value: &amp;quot;&amp;quot; });

  const [badge] = cf.nu(&amp;quot;div&amp;quot;)
    .content(({ name }) =&amp;gt; `Hello! My name is ${name}`)
    .deps({ name })
    .done();

  return [badge, name];
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With the new children API in v4, you can also use cf-slot elements to create
composable components:&lt;/p&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;const Card = (title) =&amp;gt; {
  const [card] = cf.nu(&amp;quot;div.card&amp;quot;)
    .html(`
      &amp;lt;h2&amp;gt;${title}&amp;lt;/h2&amp;gt;
      &amp;lt;cf-slot name=&amp;quot;content&amp;quot;&amp;gt;&amp;lt;/cf-slot&amp;gt;
    `)
    .done();

  return card;
};

// Usage
const [content] = cf.nu(&amp;quot;p&amp;quot;).content(&amp;quot;Card content&amp;quot;).done();
const [wrapper] = cf.nu(&amp;quot;div&amp;quot;)
  .html(`&amp;lt;cf-slot name=&amp;quot;card&amp;quot;&amp;gt;&amp;lt;/cf-slot&amp;gt;`)
  .children({ card: [Card(&amp;quot;My Card&amp;quot;)] })
  .done();
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;

&lt;details&gt;
&lt;summary&gt;Why are escape and unescape so basic?&lt;/summary&gt;

&lt;p&gt;&lt;code&gt;escape&lt;/code&gt; and &lt;code&gt;unescape&lt;/code&gt; are intended as basic HTML sanitizers mainly for setting
element contents, etc. You are encouraged to use a different HTML sanitizer if
you need more functionality.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mathiasbynens/he&quot;&gt;he&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/apostrophecms/sanitize-html&quot;&gt;html-sanitize&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/details&gt;

&lt;p&gt;&lt;a href=&quot;/?tab=get&quot;&gt;Get campfire today!&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cf-site-div&quot; data-heading=&quot;get&quot;&gt;&lt;h3&gt;turn your dumpster fire into a campfire today!&lt;/h3&gt;
&lt;p&gt;You can include campfire into your site with just an import statement, either
from a location where you are hosting it, or from esm.sh / unkpg.&lt;/p&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;import cf from &amp;quot;https://esm.sh/campfire.js@4&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or&lt;/p&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;import { ListStore, nu } from &amp;quot;https://esm.sh/campfire.js@4&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you use a bundler or want to write in TypeScript, you can install Campfire
from npm. This gives you full TypeScript support as well as TSDoc comments.&lt;/p&gt;
&lt;p&gt;To install:&lt;/p&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;npm install --save-dev campfire.js
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then in your code:&lt;/p&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;import cf from &amp;quot;campfire.js&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Good luck, and thank you for choosing Campfire!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cf-site-div&quot; data-heading=&quot;docs&quot;&gt;&lt;h3&gt;using campfire 4.0.0&lt;/h3&gt;
&lt;p&gt;View the &lt;a href=&quot;/site/docs/modules/campfire.html&quot;&gt;full API reference&lt;/a&gt; for detailed
descriptions of the methods and classes provided by Campfire.&lt;/p&gt;
&lt;h4&gt;quick reference&lt;/h4&gt;
&lt;p&gt;Campfire provides the following methods and classes:&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;&lt;code&gt;nu()&lt;/code&gt; - element creation helper&lt;/summary&gt;

&lt;p&gt;Creates a new DOM element with a fluent builder API.&lt;/p&gt;
&lt;h5&gt;Create a simple element&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;const [div] = cf.nu(&amp;quot;div&amp;quot;)
  .content(&amp;quot;Hello World&amp;quot;)
  .attr(&amp;quot;id&amp;quot;, &amp;quot;greeting&amp;quot;)
  .done();
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Button with click handler&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;const [button] = cf.nu(&amp;quot;button#submit.primary&amp;quot;)
  .content(&amp;quot;Submit&amp;quot;)
  .attr(&amp;quot;type&amp;quot;, &amp;quot;submit&amp;quot;)
  .on(&amp;quot;click&amp;quot;, () =&amp;gt; console.log(&amp;quot;Clicked!&amp;quot;))
  .style(&amp;quot;backgroundColor&amp;quot;, &amp;quot;blue&amp;quot;)
  .done();
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Element with classes&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;const [card] = cf.nu(&amp;quot;.card.shadow&amp;quot;) // Creates div by default
  .content(&amp;quot;Card content&amp;quot;)
  .done();
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Element with reactive template using NuBuilder::html()&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;const name = cf.store({ value: &amp;quot;John&amp;quot; });
const role = cf.store({ value: &amp;quot;User&amp;quot; });

const [profile] = cf.nu(&amp;quot;div.profile&amp;quot;)
  .deps({ name, role })
  // render function runs again whenever name/role change
  .render(({ name, role }, { b }) =&amp;gt;
    b
      .html`&amp;lt;h2&amp;gt;${name}&amp;lt;/h2&amp;gt;&amp;lt;p&amp;gt;Role: ${role}&amp;lt;/p&amp;gt;`
      .style(&amp;quot;color&amp;quot;, role === &amp;quot;Admin&amp;quot; ? &amp;quot;red&amp;quot; : &amp;quot;blue&amp;quot;)
  )
  .done();
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Reactive content with builder pattern&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;const name = cf.store({ value: &amp;quot;John&amp;quot; });
const admin = cf.store({ value: false });

const [greeting] = cf.nu(&amp;quot;h1&amp;quot;)
  .deps({ name, admin })
  .render(({ name, admin }, { b }) =&amp;gt; b
    .content(`Hello, ${name}!`)
    .style(&amp;quot;color&amp;quot;, admin ? &amp;quot;red&amp;quot; : &amp;quot;black&amp;quot;)
    .attr(&amp;quot;title&amp;quot;, admin ? &amp;quot;Administrator&amp;quot; : &amp;quot;User&amp;quot;);
  )
  .done();
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Direct HTML templating in render function&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;const name = cf.store({ value: &amp;quot;John&amp;quot; });

const renderGreeting = (name: string) =&amp;gt; 
  cf.html`&amp;lt;span&amp;gt;Hello, ${name}&amp;lt;/span&amp;gt;`

const [greeting] = cf.nu(&amp;quot;h1&amp;quot;)
  .deps({ name })
  // b.html() sets innerHTML without escaping
  // use b.content() to do it safely
  .render(({ name }, { b }) =&amp;gt; b.html(renderGreeting(name)))
  .done();

// or you can disable escaping with nu(...).raw(true).done()
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Select multiple created elements with &lt;code&gt;.gimme()&lt;/code&gt;&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;const [card, title, desc] = cf.nu(&amp;quot;div.card&amp;quot;)
  .html(`
    &amp;lt;h2 class=&amp;quot;title&amp;quot;&amp;gt;Card Title&amp;lt;/h2&amp;gt;
    &amp;lt;p class=&amp;quot;desc&amp;quot;&amp;gt;Description&amp;lt;/p&amp;gt;
  `)
  .gimme(&amp;quot;.title&amp;quot;, &amp;quot;.desc&amp;quot;) // Variadic - pass any number of selectors
  .done();
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Compose elements with reactive children&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;const parentData = cf.store({ value: &amp;quot;Parent content&amp;quot; });
const childData = cf.store({ value: &amp;quot;Child content&amp;quot; });
// Parent with slots for child components
const [parent] = cf.nu(&amp;quot;section&amp;quot;, {
  deps: { data: parentData },
  render: ({ data }) =&amp;gt; `
    &amp;lt;h3&amp;gt;${data}&amp;lt;/h3&amp;gt;
    &amp;lt;cf-slot name=&amp;quot;child&amp;quot;&amp;gt;&amp;lt;/cf-slot&amp;gt;
  `,
  children: {
    // Child components maintain independent reactivity
    // and are preserved between re-renders of the parent
    child: cf.nu(&amp;quot;div&amp;quot;)
      .deps({ data: childData })
      .render(({ data }) =&amp;gt; data)
      .done(),
  },
}).done();
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Using an existing element with nu()&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;// Get a reference to an existing element
const existing = document.getElementById(&amp;quot;my-element&amp;quot;);

// Add reactive behavior to it
cf.nu(existing, {
  deps: { message },
  render: ({ message }, { b }) =&amp;gt; {
    return b
      .content(`Current message: ${message}`)
      .style(&amp;quot;color&amp;quot;, message.length &amp;gt; 20 ? &amp;quot;red&amp;quot; : &amp;quot;black&amp;quot;);
  },
}).done();
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Clearing attributes and styles conditionally&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;const disabled = cf.store({ value: false });
const theme = cf.store({ value: &amp;quot;light&amp;quot; });

const themes = {
  dark: { backgroundColor: &amp;quot;#303030&amp;quot;, color: &amp;quot;white&amp;quot; },
  light: { backgroundColor: &amp;quot;#f5f4f0&amp;quot;, color: &amp;quot;#202020&amp;quot; },
};

const [button] = cf.nu(&amp;quot;button&amp;quot;)
  .content(&amp;quot;Click me&amp;quot;)
  .deps({ disabled, theme })
  .render(({ disabled, theme }, { b }) =&amp;gt; {
    // Conditionally set or clear attributes (empty string clears)
    b.attr(&amp;quot;disabled&amp;quot;, disabled ? &amp;quot;disabled&amp;quot; : &amp;quot;&amp;quot;);

    b.style(&amp;quot;backgroundColor&amp;quot;, themes[theme].backgroundColor);
    b.style(&amp;quot;color&amp;quot;, themes[theme].color);
    return b;
  })
  // assign click listener
  .on(&amp;quot;click&amp;quot;, () =&amp;gt; theme.update(theme.value === &amp;quot;light&amp;quot; ? &amp;quot;dark&amp;quot; : &amp;quot;light&amp;quot;))
  .done();
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;

&lt;details&gt;
&lt;summary&gt;&lt;code&gt;store()&lt;/code&gt; - reactive data stores&lt;/summary&gt;

&lt;p&gt;Creates reactive data stores to manage state with automatic UI updates.&lt;/p&gt;
&lt;h5&gt;A simple value store&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;const counter = cf.store({ value: 0 });
counter.update(5); // Sets value to 5
counter.value; // Gets current value (5)
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Subscribe to changes&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;counter.on(&amp;quot;change&amp;quot;, (event) =&amp;gt; {
  console.log(`Value changed to ${event.value}`);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;List store for arrays&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;const todoList = cf.store({ type: &amp;quot;list&amp;quot;, value: [&amp;quot;Buy milk&amp;quot;] });
todoList.push(&amp;quot;Walk dog&amp;quot;); // Adds to the end
todoList.remove(0); // Removes first item
todoList.clear(); // Empties the list
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Map store for key-value data&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;const user = cf.store({
  type: &amp;quot;map&amp;quot;,
  value: { name: &amp;quot;John&amp;quot;, age: 30 },
});
user.set(&amp;quot;location&amp;quot;, &amp;quot;New York&amp;quot;); // Add/update a property
user.delete(&amp;quot;age&amp;quot;); // Remove a property
user.clear(); // Empty the map
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Subscribe to all events with any()&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;todoList.any((event) =&amp;gt; {
  console.log(`Event type: ${event.type}`);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;

&lt;details&gt;
&lt;summary&gt;&lt;code&gt;select()&lt;/code&gt; - element selection&lt;/summary&gt;

&lt;p&gt;Selects elements from the DOM with a unified API.&lt;/p&gt;
&lt;h5&gt;Select a single element (returns an array with one item)&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;const [header] = cf.select({ s: &amp;quot;#page-header&amp;quot; });
// or if you need the ref for passing somewhere:
const header = cf.select({ s: &amp;quot;#page-header&amp;quot;, single: true });
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Select from a specific parent element&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;const [submitButton] = cf.select({
  s: &amp;#39;button[type=&amp;quot;submit&amp;quot;]&amp;#39;,
  from: formElement,
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Select multiple elements&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;const paragraphs = cf.select({
  s: &amp;quot;p&amp;quot;,
  all: true,
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Combining with other operations&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;cf.select({ s: &amp;quot;.cards&amp;quot;, all: true }).forEach((card) =&amp;gt; {
  cf.extend(card, { style: { border: &amp;quot;1px solid black&amp;quot; } });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;

&lt;details&gt;
&lt;summary&gt;&lt;code&gt;insert()&lt;/code&gt; - element insertion&lt;/summary&gt;

&lt;p&gt;Inserts elements into the DOM at specific positions.&lt;/p&gt;
&lt;h5&gt;Insert at the end of a container&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;cf.insert([elt], { into: container });
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Insert at the start of a container&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;cf.insert([elt], { into: container, at: &amp;quot;start&amp;quot; });
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Insert before (as siblings of) another element&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;cf.insert([elt], { before: referenceElement });
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Insert multiple elements after (as siblings of) another element&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;cf.insert([elt1, elt2], { after: referenceElement });
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Create and insert in one step&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;cf.insert(cf.nu().content(&amp;quot;New content&amp;quot;).done(), { into: document.body });
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;

&lt;details&gt;
&lt;summary&gt;&lt;code&gt;html()&lt;/code&gt; - auto-escaping template literal and element builder method&lt;/summary&gt;

&lt;p&gt;Creates HTML strings with automatic escaping of interpolated values.&lt;/p&gt;
&lt;h5&gt;Basic usage with automatic escaping&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;const username = &amp;#39;&amp;lt;script&amp;gt;alert(&amp;quot;XSS&amp;quot;)&amp;lt;/script&amp;gt;&amp;#39;;
const greeting = cf.html`Hello, ${username}!`;
// Result: &amp;quot;Hello, &amp;amp;lt;script&amp;amp;gt;alert(&amp;quot;XSS&amp;quot;)&amp;amp;lt;/script&amp;amp;gt;!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Use r() to disable escaping for trusted content&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;const trusted = cf.r(&amp;#39;&amp;quot;&amp;lt;b&amp;gt;Bold text&amp;lt;/b&amp;gt;&amp;quot;&amp;#39;);
const message = cf.html`Safe message: ${trusted}`;
// Result: &amp;quot;Safe message: &amp;quot;&amp;lt;b&amp;gt;Bold text&amp;lt;/b&amp;gt;&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Use with element creation&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;const [div] = cf.nu(&amp;quot;div&amp;quot;)
  .deps({ user })
  // .html() is equivalent to .content().raw(true)
  .html(({ user }) =&amp;gt; cf.html`&amp;lt;h1&amp;gt;Title&amp;lt;/h1&amp;gt;&amp;lt;p&amp;gt;${user}&amp;lt;/p&amp;gt;`)
  .done();
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;

&lt;details&gt;
&lt;summary&gt;&lt;code&gt;mustache()&lt;/code&gt; and &lt;code&gt;template()&lt;/code&gt; - reusable and composable string templates&lt;/summary&gt;

&lt;p&gt;A lightweight implementation of the Mustache templating system for string
interpolation.&lt;/p&gt;
&lt;h5&gt;Basic variable interpolation (escaped by default)&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;const result = cf.mustache(&amp;quot;Hello, {{ name }}!&amp;quot;, { name: &amp;quot;John&amp;quot; });
// Result: &amp;quot;Hello, John!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Unescaped HTML content&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;const result = cf.mustache(&amp;quot;Welcome, {{{ userHtml }}}!&amp;quot;, {
  userHtml: &amp;quot;&amp;lt;b&amp;gt;Admin&amp;lt;/b&amp;gt;&amp;quot;,
});
// Result: &amp;quot;Welcome, &amp;lt;b&amp;gt;Admin&amp;lt;/b&amp;gt;!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Sections - conditionally show content&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;const result = cf.mustache(
  &amp;quot;{{#loggedIn}}Welcome back!{{/loggedIn}}{{^loggedIn}}Please log in.{{/loggedIn}}&amp;quot;,
  { loggedIn: true },
);
// Result: &amp;quot;Welcome back!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Array iteration with sections&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;const result = cf.mustache(
  &amp;quot;&amp;lt;ul&amp;gt;{{#items}}&amp;lt;li&amp;gt;{{name}}&amp;lt;/li&amp;gt;{{/items}}&amp;lt;/ul&amp;gt;&amp;quot;,
  { items: [{ name: &amp;quot;Item 1&amp;quot; }, { name: &amp;quot;Item 2&amp;quot; }] },
);
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Working with primitive arrays&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;const result = cf.mustache(
  &amp;quot;Numbers: {{#numbers}}{{.}}, {{/numbers}}&amp;quot;,
  { numbers: [1, 2, 3] },
);
// Result: &amp;quot;Numbers: 1, 2, 3, &amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Context changes with object values&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;const result = cf.mustache(
  &amp;quot;{{#user}}Name: {{name}}, Age: {{age}}{{/user}}&amp;quot;,
  { user: { name: &amp;quot;John&amp;quot;, age: 30 } },
);
// Result: &amp;quot;Name: John, Age: 30&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Nested sections&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;const result = cf.mustache(
  &amp;quot;{{#user}}{{name}} {{#admin}}(Admin){{/admin}}{{^admin}}(User){{/admin}}{{/user}}&amp;quot;,
  { user: { name: &amp;quot;John&amp;quot;, admin: true } },
);
// Result: &amp;quot;John (Admin)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Escaping mustache syntax&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;const result = cf.mustache(
  &amp;quot;This is not a variable: \\{{ name }}&amp;quot;,
  { name: &amp;quot;John&amp;quot; },
);
// Result: &amp;quot;This is not a variable: {{ name }}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Create reusable template function (compile once, render many times)&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;// Compile template once
const greet = cf.template(&amp;quot;Hello, {{ name }}!&amp;quot;);

// Use multiple times with different data
const aliceGreeting = greet({ name: &amp;quot;Alice&amp;quot; }); // &amp;quot;Hello, Alice!&amp;quot;
const bobGreeting = greet({ name: &amp;quot;Bob&amp;quot; }); // &amp;quot;Hello, Bob!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;

&lt;details&gt;
&lt;summary&gt;&lt;code&gt;extend()&lt;/code&gt; - element modification&lt;/summary&gt;

&lt;p&gt;Modifies existing DOM elements with the same options as &lt;code&gt;nu()&lt;/code&gt;.&lt;/p&gt;
&lt;h5&gt;Basic usage&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;const element = document.querySelector(&amp;quot;#my-element&amp;quot;);
cf.extend(element, {
  contents: &amp;quot;New content&amp;quot;,
  style: { color: &amp;quot;red&amp;quot;, fontSize: &amp;quot;16px&amp;quot; },
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Add event handlers&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;cf.extend(element, {
  on: {
    click: () =&amp;gt; console.log(&amp;quot;Clicked!&amp;quot;),
    mouseover: () =&amp;gt; element.style.opacity = &amp;quot;0.8&amp;quot;,
  },
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;With reactive data&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;const titleStore = cf.store({ value: &amp;quot;Initial Title&amp;quot; });

cf.extend(pageHeader, {
  contents: ({ title }) =&amp;gt; `Page: ${title}`,
  deps: { title: titleStore },
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Composing elements with extend&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;const childContent = cf.store({ value: &amp;quot;Child text&amp;quot; });

cf.extend(container, {
  contents: `&amp;lt;h2&amp;gt;Container&amp;lt;/h2&amp;gt;
&amp;lt;cf-slot name=&amp;quot;childSlot&amp;quot;&amp;gt;&amp;lt;/cf-slot&amp;gt;`,
  raw: true,
  children: {
    childSlot: cf.nu(&amp;quot;span&amp;quot;)
      .deps({ childContent })
      .content(({ childContent }) =&amp;gt; childContent)
      .ref(),
  },
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;

&lt;details&gt;
&lt;summary&gt;&lt;code&gt;empty()&lt;/code&gt; and &lt;code&gt;rm()&lt;/code&gt; - element cleanup&lt;/summary&gt;

&lt;p&gt;Remove elements or their contents from the DOM.&lt;/p&gt;
&lt;h5&gt;Empty an element (removes all children)&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;cf.empty(container);
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Remove element entirely&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;cf.rm(element);
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;

&lt;details&gt;
&lt;summary&gt;&lt;code&gt;escape()&lt;/code&gt; and &lt;code&gt;unescape()&lt;/code&gt; - string sanitization&lt;/summary&gt;

&lt;p&gt;Simple HTML escaping and unescaping utilities. These are the bare minimum for
inserting text into the DOM - you should look to a different library for more
complex needs.&lt;/p&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;escape(&amp;quot;&amp;lt;script&amp;gt;alert(&amp;#39;XSS&amp;#39;)&amp;lt;/script&amp;gt;&amp;quot;); // &amp;quot;&amp;amp;lt;script&amp;amp;gt;alert(&amp;#39;XSS&amp;#39;)&amp;amp;lt;/script&amp;amp;gt;&amp;quot;

// Unescape previously escaped strings
unescape(&amp;quot;&amp;amp;lt;script&amp;amp;gt;alert(&amp;#39;XSS&amp;#39;)&amp;amp;lt;/script&amp;amp;gt;&amp;quot;); // &amp;quot;&amp;lt;script&amp;gt;alert(&amp;#39;XSS&amp;#39;)&amp;lt;/script&amp;gt;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;

&lt;details&gt;
&lt;summary&gt;&lt;code&gt;onload()&lt;/code&gt; - DOM ready handler&lt;/summary&gt;

&lt;p&gt;Executes code when the DOM is fully loaded.&lt;/p&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;cf.onload(() =&amp;gt; {
  // Initialize application
  const [app] = cf.nu(&amp;quot;div#app&amp;quot;).done();
  cf.insert(app, { into: document.body });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;

&lt;details&gt;
&lt;summary&gt;&lt;code&gt;seq()&lt;/code&gt; - sequence generator&lt;/summary&gt;

&lt;p&gt;Generates numerical sequences for iteration.&lt;/p&gt;
&lt;h5&gt;Range from 0 to 5 (exclusive)&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;cf.seq(5); // [0, 1, 2, 3, 4]
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Range from 2 to 7 (exclusive)&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;cf.seq(2, 7); // [2, 3, 4, 5, 6]
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Range with custom step&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;cf.seq(1, 10, 2); // [1, 3, 5, 7, 9]
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Creating multiple elements with seq&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;cf.seq(5).forEach((i) =&amp;gt; {
  const [item] = cf.nu(&amp;quot;li&amp;quot;)
    .content(`Item ${i + 1}`)
    .done();
  cf.insert(item, { into: listElement });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;

&lt;details&gt;
&lt;summary&gt;&lt;code&gt;callbackify()&lt;/code&gt; - convert Promise-based functions to callback style&lt;/summary&gt;

&lt;p&gt;Converts a function that returns a Promise into a function that accepts a
Node-style callback. Especially useful for using async operations in Store event
handlers.&lt;/p&gt;
&lt;h5&gt;Using with Store event handlers&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;// Store event handlers are expected to be synchronous
// This pattern enables async operations without marking the handler as async

// Define an async operation
const loadEditorAsync = async (postId) =&amp;gt; {
  const content = await fetchPostContent(postId);
  const [element, editor] = await createEditor(content);
  return { element, editor };
};

// In a store subscription:
postStore.on(&amp;quot;update&amp;quot;, (event) =&amp;gt; {
  // Launch the async operation properly
  callbackify(loadEditorAsync)(
    (err, result) =&amp;gt; {
      if (err) {
        console.error(&amp;quot;Failed to load editor:&amp;quot;, err);
        return;
      }

      // Handle the result when the async operation completes
      const { element, editor } = result;
      cf.insert(element, { into: container });
      postStore.set(&amp;quot;editor&amp;quot;, editor);
    },
    event.value,
  );
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Integrating with callback-based APIs&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;// Original async function
const getUser = async (userId) =&amp;gt; {
  const response = await fetch(`/api/users/${userId}`);
  return response.json();
};

// Convert to callback style
const getUserCb = cf.callbackify(getUser);

// Use with a callback
getUserCb((err, data) =&amp;gt; {
  if (err) {
    console.error(&amp;quot;Error:&amp;quot;, err);
    return;
  }
  console.log(&amp;quot;User data:&amp;quot;, data);
}, &amp;quot;12345&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Error handling with callbackify&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;const processItems = async (items) =&amp;gt; {
  // This might throw errors
  const results = await Promise.all(items.map(processItem));
  return results;
};

// Safe error handling with callbackify
cf.store({ value: [] }).on(&amp;quot;update&amp;quot;, (event) =&amp;gt; {
  cf.callbackify(processItems)(
    (error, results) =&amp;gt; {
      if (error) {
        errorStore.update(`Processing failed: ${error.message}`);
        return;
      }
      resultStore.update(results);
    },
    event.value,
  );
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;

&lt;details&gt;
&lt;summary&gt;&lt;code&gt;poll()&lt;/code&gt; - execute a function at regular intervals&lt;/summary&gt;

&lt;p&gt;Repeatedly executes a function at specified intervals with proper cleanup.&lt;/p&gt;
&lt;h5&gt;Basic polling example&lt;/h5&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;// Check for updates every 5 seconds, starting 5 seconds from now
const stopPolling = cf.poll(() =&amp;gt; checkMessages(user), 5000);

// Or call immediately:
const stopPolling = cf.poll(
  () =&amp;gt; checkMessages(user),
  5000,
  /* callNow */ true,
);

// Later, when you want to stop polling:
stopPolling();
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Passing messages out of poll()&lt;/h5&gt;
&lt;p&gt;You can use stores to pass messages out of the poll function, aside from just
using good old-fashioned closures:&lt;/p&gt;
&lt;pre class=&quot;microlight&quot;&gt;&lt;code&gt;const messages = cf.store({ type: &amp;quot;list&amp;quot;, value: [] });

const stopMessagePolling = cf.poll(
  () =&amp;gt; {
    fetch(&amp;quot;/api/messages&amp;quot;)
      .then((response) =&amp;gt; response.json())
      .then((data) =&amp;gt; messages.update(data));
  },
  10000,
  true,
);

// Cancel polling when component is removed
const cleanup = () =&amp;gt; {
  stopMessagePolling();
  messages.dispose();
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;/div&gt;
&lt;div class=&quot;cf-site-div&quot; data-heading=&quot;playground&quot;&gt;&lt;h3&gt;try before you buy&lt;/h3&gt;
&lt;p&gt;Try one of these demos, or do your own thing!&lt;/p&gt;
&lt;ul id=&#39;playground-demo-list&#39;&gt;
&lt;/ul&gt;

&lt;div id=&#39;cf-editor-controls&#39;&gt;
  &lt;a href=&#39;javascript:void(0)&#39; id=&#39;cf-editor-clear&#39;&gt;Clear All&lt;/a&gt;
  &lt;a href=&#39;javascript:void(0)&#39; id=&#39;cf-editor-dl&#39;&gt;Download&lt;/a&gt;
&lt;/div&gt;

&lt;div class=&#39;editor-wrapper&#39;&gt;
  &lt;div class=&#39;cf-editor-html&#39;&gt;&lt;/div&gt;
  &lt;div class=&#39;cf-editor-css&#39;&gt;&lt;/div&gt;
  &lt;div class=&#39;cf-editor-javascript&#39;&gt;&lt;/div&gt;
  &lt;div class=&#39;cf-editor-output&#39;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

        <div class='footer'>
            <a href='https://github.com/xyzshantaram/campfire'>Campfire on GitHub</a>
            <a href='https://github.com/xyzshantaram/campfire/blob/main/index.html'>This site on GitHub</a>
            <p>
                Campfire is free, open-source software available under <a
                    href='https://github.com/xyzshantaram/campfire/blob/main/LICENSE'>the MIT License</a>.
            </p>
        </div>
    </div>

    <div id='mask'>
        <span>loading...</span>
    </div>


    <script defer type='module' src='site/main.js'></script>
</body>

</html>